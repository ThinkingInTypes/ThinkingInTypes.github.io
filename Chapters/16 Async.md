# Async

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Type Annotations for Async Functions

Async functions (`async def`) support type annotations similarly to regular functions, clearly specifying their input and return types:

```python
# example_1.py
import asyncio

async def fetch_data(url: str) -> str:
    await asyncio.sleep(1)
    return f"Data from {url}"
```

Clear type annotations improve readability and debugging, especially in asynchronous codebases.

## Annotating `Coroutine`, `Awaitable`, and Async Generators

Python provides specific annotations for asynchronous constructs, enhancing type safety and correctness:

### `Coroutine`

Explicitly type coroutines:

```python
# example_2.py
from typing import Coroutine

async def get_user(user_id: int) -> dict:
    return {"id": user_id, "name": "Alice"}

async def main() -> Coroutine[None, None, dict]:
    user = await get_user(123)
    return user
```

### `Awaitable`

For functions returning awaitable results:

```python
# example_3.py
from typing import Awaitable

async def fetch(url: str) -> str:
    return f"Content from {url}"

def schedule_fetch(url: str) -> Awaitable[str]:
    return fetch(url)
```

### Async Generators

For asynchronous generators:

```python
# example_4.py
from typing import AsyncGenerator

async def stream_data() -> AsyncGenerator[int, None]:
    for i in range(5):
        yield i
```

These specialized annotations clarify asynchronous behaviors and interactions.

## Type-safe Async Context Managers

Async context managers manage resources in asynchronous contexts, with annotations improving safety and clarity:

```python
# example_5.py
from contextlib import asynccontextmanager
from typing import AsyncGenerator

@asynccontextmanager
async def database_connection() -> AsyncGenerator[str, None]:
    connection = "db_connection"
    try:
        yield connection
    finally:
        await asyncio.sleep(1)  # simulate closing connection

async def main():
    async with database_connection() as conn:
        print(f"Using {conn}")
```

Annotations provide explicit clarity, improving resource management and reducing errors.

## Best Practices for Typed Async Python Applications

### Clearly Annotate Async Functions

- Explicitly state return types to enhance readability.
- Use specialized async annotations (`Awaitable`, `Coroutine`) for clarity.

### Consistent Use of Async Types

- Avoid mixing synchronous and asynchronous types inconsistently.
- Clearly differentiate async generators and synchronous generators.

### Use Async Context Managers Effectively

- Annotate context managers clearly to indicate resource management explicitly.
- Ensure proper setup and teardown in async contexts.

### Integrate Async Type Checking in CI/CD

- Include `mypy` or `pyright` checks in CI pipelines specifically for async code.
- Regularly verify correct async annotations to maintain consistency.

Applying these best practices ensures robust, readable, and maintainable asynchronous Python code.
