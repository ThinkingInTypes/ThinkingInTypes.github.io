# Generics

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Defining Custom Generics with `TypeVar` and `Generic`

Custom generics allow functions and classes to handle various types flexibly:

### Using `TypeVar`

```python
# example_1.py
from typing import TypeVar, List

T = TypeVar("T")


def first_item(items: List[T]) -> T:
    return items[0]


print(first_item([1, 2, 3]))  # returns int
## 1
print(first_item(["a", "b"]))  # returns str
## a
```

### Generic Classes

```python
# example_2.py
from dataclasses import dataclass
from typing import Generic, TypeVar

T = TypeVar("T")  # Declare a type variable


@dataclass
class Box(Generic[T]):
    content: T


box_int = Box(123)  # Box[int]
box_str = Box("hello")  # Box[str]
```

Custom generics enhance code reusability and type safety.

## Using Constraints and Bounds with Generics

Generics can include constraints and bounds to restrict allowed types:

### Constraints

```python
# example_3.py
from typing import TypeVar

U = TypeVar("U", int, float)


def add(a: U, b: U) -> U:
    return a + b


add(1, 2)  # valid
add(1.5, 2.5)  # valid
# add("a", "b")  # invalid, detected by type checker
```

### Bounds

```python
# example_4.py
from typing import TypeVar


class Animal:
    def speak(self) -> str:
        return "..."


A = TypeVar("A", bound=Animal)


def animal_sound(animal: A) -> str:
    return animal.speak()


class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"


print(animal_sound(Dog()))  # "Woof!"
## Woof!
```

Constraints and bounds improve specificity in generic type annotations, enhancing code clarity and correctness.
