# Specialized Tools

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Misunderstanding Class Attributes

This chapter contains additional tools that modify the normal behavior of class attributes.
It's important to understand that this behavior is created by the tool, and that ordinary classes do not behave this way.
Read the [Class Attributes] appendix for deeper understanding.

## Typed NamedTuples

A typed `NamedTuple` combines tuple immutability with type annotations and named fields:

```python
# named_tuple.py
from typing import NamedTuple

class Coordinates(NamedTuple):
    latitude: float
    longitude: float

coords = Coordinates(51.5074, -0.1278)
print(coords.latitude)  # 51.5074
```

`NamedTuple` provides clarity, immutability, and easy unpacking, ideal for simple structured data.

## Leveraging TypedDicts for Structured Data

`TypedDict` is useful when defining dictionary structures with known keys and typed values:

```python
# typed_dict.py
from typing import TypedDict

class UserProfile(TypedDict):
    username: str
    email: str
    age: int

user: UserProfile = {"username": "alice", "email": "alice@example.com", "age": 30}
```

`TypedDict` clarifies expected keys and types, providing type safety for dictionary data.

### Optional Fields in TypedDict

You can specify optional fields using `NotRequired` (Python 3.11+) or `total=False`:

```python
# optional_typed_dict_fields.py
from typing import TypedDict, NotRequired

class UserSettings(TypedDict):
    theme: str
    notifications_enabled: NotRequired[bool]

settings: UserSettings = {"theme": "dark"}
```

This flexibility allows clear definitions for complex, partially-optional data structures.

## Patterns for Strongly-Typed Domain Models

Strongly-typed domain models help clearly represent domain logic, improving robustness and maintainability:

### Using Dataclasses and Enums

```python
# dataclasses_and_enums.py
from dataclasses import dataclass
from enum import Enum

class Status(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"

@dataclass
class User:
    id: int
    name: str
    status: Status

user = User(id=1, name="Alice", status=Status.ACTIVE)
```

### Combining Dataclasses with Protocols

```python
# dataclasses_and_protocols.py
from typing import Protocol

class Identifiable(Protocol):
    id: int

@dataclass
class User:
    id: int
    name: str

@dataclass
class Product:
    id: int
    price: float

def print_id(entity: Identifiable) -> None:
    print(f"ID: {entity.id}")

print_id(User(1, "Alice"))
print_id(Product(101, 19.99))
```

### Domain-Driven Design (DDD)

Define domain entities explicitly to enhance domain logic expressiveness:

```python
# ddd.py
@dataclass
class Order:
    order_id: int
    products: List[Product]

    def total_price(self) -> float:
        return sum(product.price for product in self.products)
```

Strongly-typed domain models help catch issues early, facilitating clearer, safer, and more maintainable codebases.
