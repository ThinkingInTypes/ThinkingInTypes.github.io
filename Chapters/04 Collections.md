# Collections

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Annotating Lists, Tuples, Sets, Dictionaries

Python provides built-in collection types such as lists, tuples, sets, and dictionaries. Annotating these clearly specifies their expected contents:

### Lists

```python
# example_1.py
from typing import List

scores: List[int] = [95, 85, 75]
```

### Tuples

```python
# example_2.py
from typing import Tuple

coordinates: Tuple[float, float] = (23.5, 45.8)
```

### Sets

```python
# example_3.py
from typing import Set

unique_ids: Set[str] = {"abc", "xyz", "123"}
```

### Dictionaries

```python
# example_4.py
from typing import Dict

user_data: Dict[str, int] = {"Alice": 30, "Bob": 25}
```

These annotations enhance readability and help catch type-related errors early.

## Annotations without Imports

Starting from Python 3.9, built-in collection types support direct annotations without importing from `typing`:

```python
# example_5.py
scores: list[int] = [95, 85, 75]
user_data: dict[str, float] = {"Alice": 95.5, "Bob": 85.3}
```

This simplified syntax enhances readability and reduces verbosity.

## Specialized Annotations (`Sequence`, `Mapping`, `Iterable`, `Iterator`)

Python provides specialized annotations for greater flexibility:

### `Sequence`

- For any ordered collection supporting indexing:

```python
# example_6.py
from typing import Sequence

def average(numbers: Sequence[float]) -> float:
    return sum(numbers) / len(numbers)
```

### `Mapping`

- For dictionary-like objects:

```python
# example_7.py
from typing import Mapping

def get_user_age(users: Mapping[str, int], username: str) -> int:
    return users.get(username, 0)
```

### `Iterable` and `Iterator`

- For looping over items:

```python
# example_8.py
from typing import Iterable, Iterator

def print_items(items: Iterable[str]) -> None:
    for item in items:
        print(item)


def generate_numbers(n: int) -> Iterator[int]:
    for i in range(n):
        yield i
```

Specialized annotations enable broader compatibility with various collection types.
