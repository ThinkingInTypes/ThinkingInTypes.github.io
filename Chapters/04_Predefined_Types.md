# Predefined Types

> This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Built-in Types (`int`, `str`, `float`, `bool`, `None`)

Python supports type annotations for its fundamental built-in types, allowing developers to clarify expected types of variables and function arguments explicitly:

```python
# example_1.py
age: int = 25
name: str = "Alice"
salary: float = 45000.50
is_active: bool = True
no_value: None = None
```

These annotations immediately communicate intent, simplifying code readability and maintainability.

## Variables and Functions

Type annotations can be added to variables and function parameters to indicate expected data types:

### Variables

```python
# example_2.py
user_id: int = 123
username: str = "admin"
```

### Functions

```python
# example_3.py
def greet_user(username: str) -> str:
    return f"Welcome, {username}!"
```

Annotations clearly specify expected input and output types, helping prevent bugs and errors.

## Optional Types and Default Values

Sometimes a variable or function argument can be a specific type or `None`.
Python uses `Optional` from `typing` to indicate this:

```python
# example_4.py
from typing import Optional


def find_user(user_id: int) -> Optional[str]:
    if user_id == 1:
        return "Alice"
    return None
```

Default values with optional annotations:

```python
# example_5.py
from typing import Optional


def greet(name: Optional[str] = None) -> str:
    if name:
        return f"Hello, {name}!"
    return "Hello!"
```

## Using Union Types (`|` operator vs. `Union`)

Python allows you to specify multiple acceptable types for variables or parameters.
Traditionally, the `Union` type was used, but Python 3.10 introduced the `|` operator for readability:

### Using `Union`

```python
# example_6.py
from typing import Union


def process_value(value: Union[int, str]) -> str:
    return str(value)
```

### Using `|` operator (Python 3.10+)

```python
# example_7.py
def process_value(value: int | str) -> str:
    return str(value)
```

The `|` operator provides clearer and more concise syntax.

## Defining Type Aliases

Type aliases simplify complex annotations by providing a readable and reusable name for a type:

```python
# example_8.py
from typing import List

UserIDs = List[int]


def process_users(user_ids: UserIDs) -> None:
    for uid in user_ids:
        print(f"Processing user {uid}")
```

Aliases improve code clarity, especially for complex types.

## Lists, Tuples, Sets and Dictionaries

Python provides built-in collection types such as lists, tuples, sets, and dictionaries.
Annotating these clearly specifies their expected contents:

### Lists

```python
# example_9.py
from typing import List

scores: List[int] = [95, 85, 75]
```

### Tuples

```python
# example_10.py
from typing import Tuple

coordinates: Tuple[float, float] = (23.5, 45.8)
```

### Sets

```python
# example_11.py
from typing import Set

unique_ids: Set[str] = {"abc", "xyz", "123"}
```

### Dictionaries

```python
# example_12.py
from typing import Dict

user_data: Dict[str, int] = {"Alice": 30, "Bob": 25}
```

These annotations enhance readability and help catch type-related errors early.

## Annotations without Imports

Starting from Python 3.9, built-in collection types support direct annotations without importing from `typing`:

```python
# example_13.py
scores: list[int] = [95, 85, 75]
user_data: dict[str, float] = {"Alice": 95.5, "Bob": 85.3}
```

This simplified syntax enhances readability and reduces verbosity.

## Specialized Annotations (`Sequence`, `Mapping`, `Iterable`, `Iterator`)

Python provides specialized annotations for greater flexibility:

### `Sequence`

- For any ordered collection supporting indexing:

```python
# example_14.py
from typing import Sequence


def average(numbers: Sequence[float]) -> float:
    return sum(numbers) / len(numbers)
```

### `Mapping`

- For dictionary-like objects:

```python
# example_15.py
from typing import Mapping


def get_user_age(
    users: Mapping[str, int], username: str
) -> int:
    return users.get(username, 0)
```

### `Iterable` and `Iterator`

- For looping over items:

```python
# example_16.py
from typing import Iterable, Iterator


def print_items(items: Iterable[str]) -> None:
    for item in items:
        print(item)


def generate_numbers(n: int) -> Iterator[int]:
    for i in range(n):
        yield i
```

Specialized annotations enable broader compatibility with various collection types.

## Common Annotation Patterns and Errors

### Common Patterns

- Clearly annotate function parameters and return values.
- Use type aliases for complex or repetitive types.
- Use optional annotations when values can legitimately be `None`.

### Common Errors

- Incorrect annotations (e.g., annotating as `int` when the value might be `float`).
- Missing annotations on important public APIs or interfaces.
- Overuse of overly broad types like `Any`, reducing annotation benefits.

Example error:

```python
# example_17.py
from book_utils import Catch


def calculate_area(radius: int) -> float:
    return 3.14 * radius**2


with Catch():
    # Flagged by static type checker:
    calculate_area(3.5)  # type: ignore
```

Careful use of annotations combined with static checking tools significantly enhances code robustness and readability.
