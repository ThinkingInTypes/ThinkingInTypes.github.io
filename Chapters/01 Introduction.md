# Introduction

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/Thinking-In-Types/ThinkingInTypes_Book/issues)

## Dynamic vs. Static Typing: Definitions, Pros, and Cons

Python is traditionally known as a dynamically typed language.
This means the types of variables are determined at runtime rather than explicitly declared.
For example:

```python
x = 42      # x is dynamically assigned as an integer
y = "hello" # y is dynamically assigned as a string
```

In contrast, statically typed languages require explicit type declarations, and types are checked at compile time:

```java
int x = 42;       // Java explicitly defines x as an integer
String y = "hello"; // Java explicitly defines y as a String
```

**Pros of dynamic typing:**

- Faster prototyping and development
- Greater flexibility in handling different types
- Easier learning curve for beginners

**Cons of dynamic typing:**

- Runtime type errors can occur unexpectedly
- Less clarity on expected data types
- Reduced safety and predictability

**Pros of static typing:**

- Type errors caught early at compile time
- Enhanced code clarity and readability
- Improved performance and optimization opportunities

**Cons of static typing:**

- Verbose code with explicit declarations
- Potentially slower initial development
- Steeper learning curve for newcomers

## Python's Typing Evolution: From Duck Typing to Type Annotations

Python initially embraced the concept of "duck typing," where the suitability of an object is determined by the presence of methods and properties, not by its explicit type.
If it looks like a duck and quacks like a duck, it's treated as a duck:

```python
class Duck:
    def quack(self):
        print("Quack!")

def make_it_quack(bird):
    bird.quack()

make_it_quack(Duck())  # works fine
```

However, as Python projects grew in scale and complexity, the need for type safety and clearer documentation became apparent.
Python 3.5 introduced **type annotations**, allowing developers to optionally specify expected types:

```python
def greet(name: str) -> str:
    return f"Hello, {name}!"
```

This evolution combines the best of both worlds—maintaining Python's flexibility while adding optional type safety.

## Benefits of Type Annotations: Maintainability, Readability, Safety

### Maintainability

- Clearly defined types make code easier to refactor and maintain over time.
- Reduces uncertainty about the intended use of variables and functions.

### Readability

- Type annotations serve as inline documentation.
- Quickly communicates developer intentions to other team members.

### Safety

- Catch errors early, before the program runs.
- Reduces runtime exceptions due to unexpected types.

## Type Checking Tools Overview (`mypy`, `pyright`, PyCharm)

Python’s ecosystem provides robust tools to leverage type annotations:

### mypy

- One of the earliest static type checkers for Python.
- Highly configurable and widely adopted.

```bash
pip install mypy
mypy your_script.py
```

### pyright

- Developed by Microsoft, emphasizing performance and ease of use.
- Built into VSCode, offering real-time feedback.

```bash
npm install -g pyright
pyright your_script.py
```

### PyCharm

- Integrated IDE support for type checking.
- Provides immediate visual feedback as you write code.

These tools allow developers to incrementally adopt static typing, improving code reliability without sacrificing Python's dynamic roots.

## Understanding Runtime vs. Static Type Checking

### Runtime Type Checking

- Types are validated as the program executes.
- Errors surface only when problematic code is executed.

```python
def add(a, b):
    return a + b

add(1, "2")  # raises runtime TypeError
```

### Static Type Checking

- Performed before the code runs, typically during development or as part of CI/CD pipelines.
- Prevents many type-related errors by analyzing code structure.

```python
# mypy detects this error before running
def add(a: int, b: int) -> int:
    return a + b

add(1, "2")  # Static type checker flags this
```

By combining runtime flexibility with static checking, Python provides a balanced approach that empowers developers to write safe, readable, and maintainable code.
