# Basic Annotations

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Annotating Built-in Types (`int`, `str`, `float`, `bool`, `None`)

Python supports type annotations for its fundamental built-in types, allowing developers to clarify expected types of variables and function arguments explicitly:

```python
# example_1.py
age: int = 25
name: str = "Alice"
salary: float = 45000.50
is_active: bool = True
no_value: None = None
```

These annotations immediately communicate intent, simplifying code readability and maintainability.

## Annotating Variables and Functions

Type annotations can be added to variables and function parameters to indicate expected data types:

### Variables

```python
# example_2.py
user_id: int = 123
username: str = "admin"
```

### Functions

```python
# example_3.py
def greet_user(username: str) -> str:
    return f"Welcome, {username}!"
```

Annotations clearly specify expected input and output types, helping prevent bugs and errors.

## Optional Types and Default Values

Sometimes a variable or function argument can be a specific type or `None`.
Python uses `Optional` from `typing` to indicate this:

```python
# example_4.py
from typing import Optional


def find_user(user_id: int) -> Optional[str]:
    if user_id == 1:
        return "Alice"
    return None
```

Default values with optional annotations:

```python
# example_5.py
from typing import Optional


def greet(name: Optional[str] = None) -> str:
    if name:
        return f"Hello, {name}!"
    return "Hello!"
```

## Using Union Types (`|` operator vs. `Union`)

Python allows you to specify multiple acceptable types for variables or parameters.
Traditionally, the `Union` type was used, but Python 3.10 introduced the `|` operator for readability:

### Using `Union`

```python
# example_6.py
from typing import Union


def process_value(value: Union[int, str]) -> str:
    return str(value)
```

### Using `|` operator (Python 3.10+)

```python
# example_7.py
def process_value(value: int | str) -> str:
    return str(value)
```

The `|` operator provides clearer and more concise syntax.

## Defining Type Aliases

Type aliases simplify complex annotations by providing a readable and reusable name for a type:

```python
# example_8.py
from typing import List

UserIDs = List[int]


def process_users(user_ids: UserIDs) -> None:
    for uid in user_ids:
        print(f"Processing user {uid}")
```

Aliases improve code clarity, especially for complex types.

## Common Annotation Patterns and Errors

### Common Patterns

- Clearly annotate function parameters and return values.
- Use type aliases for complex or repetitive types.
- Use optional annotations when values can legitimately be `None`.

### Common Errors

- Incorrect annotations (e.g., annotating as `int` when the value might be `float`).
- Missing annotations on important public APIs or interfaces.
- Overuse of overly broad types like `Any`, reducing annotation benefits.

Example error:

```python
# example_9.py
def calculate_area(radius: int) -> float:
    return 3.14 * radius**2


calculate_area(3.5)  # R: Flagged by static type checker
```

Careful use of annotations combined with static checking tools significantly enhances code robustness and readability.
