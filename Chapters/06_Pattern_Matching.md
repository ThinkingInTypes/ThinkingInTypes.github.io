# Pattern Matching

> This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Introduction to Structural Pattern Matching (Python 3.10+)

Python 3.10 introduced structural pattern matching, providing powerful and concise syntax to match objects against specific patterns:

```python
# example_1.py
def handle_command(command: str) -> str:
    match command:
        case "start":
            return "Starting"
        case "stop":
            return "Stopping"
        case _:
            return "Unknown command"
```

Pattern matching enhances readability and maintainability, reducing the complexity of conditional logic.

## Annotating Code with Pattern Matching

Annotations can clarify patterns used in structural matching, making code clearer and aiding static type checking:

```python
# example_2.py
from typing import NamedTuple


class Success(NamedTuple):
    result: str


class Error(NamedTuple):
    error: str


def process(response: Success | Error) -> str:
    match response:
        case Success(result):
            return f"Success: {result}"
        case Error(error):
            return f"Error: {error}"
        case _:
            raise ValueError("Unhandled response type")
```

This use of annotations and pattern matching simplifies complex decision-making logic.

## Annotating Code with Pattern Matching

When combining type annotations with pattern matching, carefully structuring types enhances type checker effectiveness:

### Example with TypedDict and Pattern Matching

```python
# example_3.py
from typing import TypedDict


class Command(TypedDict):
    action: str
    payload: dict


def process_command(command: TypedDict) -> None:
    match command:
        case {"action": "create", "item": item}:
            print(f"Creating {item}")
        case {
            "action": "delete",
            "id": int() as item_id,
        }:
            print(f"Deleting item {item_id}")
        case _:
            print("Unknown command")
```

Annotations clearly define expected data shapes, improving readability and correctness.

## Type Checking Considerations with `match` Statements

Static type checkers can analyze pattern matching effectively, but careful type design is essential:

### Ensuring Consistent Patterns

Pattern matching works best with clearly annotated and structurally consistent types:

```python
# example_4.py


class Cat:
    def meow(self) -> str:
        return "Meow"


class Dog:
    def bark(self) -> str:
        return "Woof"


def animal_sound(animal: Cat | Dog) -> str:
    match animal:
        case Cat():
            return animal.meow()
        case Dog():
            return animal.bark()
        case _:
            return "Unknown"
```

Properly annotated unions simplify handling of multiple types with clarity and safety.

## Real-world Scenarios for Pattern Matching

Pattern matching is highly effective in real-world scenarios, such as:

### Handling API Responses

```python
# example_5.py
def process_response(response: dict) -> str:
    match response:
        case {"status": "success", "data": data}:
            return f"Success: {data}"
        case {"status": "error", "message": error_msg}:
            return f"Error: {error_msg}"
        case _:
            return "Unknown response format"
```

### Parsing Complex Data Structures

```python
# example_6.py
def parse_coordinates(coords: tuple) -> str:
    match coords := coords:
        case (float(lat), float(lon)):
            return f"Latitude: {lat}, Longitude: {lon}"
        case _:
            return "Invalid coordinates"
```

Pattern matching simplifies conditional logic, making code more maintainable.

## Type Checking Considerations

Ensure type annotations match patterns closely, as type checkers use them to validate correctness:

- Explicitly define type annotations for better static analysis.
- Carefully match patterns to annotated types for enhanced safety.

Properly using pattern matching alongside type annotations helps catch potential runtime errors early, resulting in safer and more readable Python code.
