# Specialized Tools

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Misunderstanding Class Attributes

This chapter contains additional tools that modify the normal behavior of class attributes.
It's important to understand that this behavior is created by the tool, and that ordinary classes do not behave this way.
Read the [Class Attributes] appendix for deeper understanding.

## Typed NamedTuples

A typed `NamedTuple` combines tuple immutability with type annotations and named fields:

```python
# named_tuple.py
from typing import NamedTuple


class Coordinates(NamedTuple):
    latitude: float
    longitude: float


coords = Coordinates(51.5074, -0.1278)
print(coords)
print(coords.latitude)
coords.latitude = 123.4567
```

`NamedTuple` provides clarity, immutability, and easy unpacking, ideal for simple structured data.

## Leveraging TypedDicts for Structured Data

`TypedDict` is useful when defining dictionary structures with known keys and typed values:

```python
# typed_dict.py
from typing import TypedDict


class UserProfile(TypedDict):
    username: str
    email: str
    age: int


user: UserProfile = {"username": "alice", "email": "alice@example.com", "age": 30}
```

`TypedDict` clarifies expected keys and types, providing type safety for dictionary data.

### Optional Fields in TypedDict

You can specify optional fields using `NotRequired` (Python 3.11+) or `total=False`:

```python
# optional_typed_dict_fields.py
from typing import TypedDict, NotRequired


class UserSettings(TypedDict):
    theme: str
    notifications_enabled: NotRequired[bool]


settings: UserSettings = {"theme": "dark"}
```

This flexibility allows clear definitions for complex, partially-optional data structures.

## Patterns for Strongly-Typed Domain Models

Strongly-typed domain models help clearly represent domain logic, improving robustness and maintainability:

### Combining Dataclasses and Enums

```python
# dataclasses_and_enums.py
from dataclasses import dataclass
from enum import Enum


class Status(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"


@dataclass
class User:
    id: int
    name: str
    status: Status


user = User(id=1, name="Alice", status=Status.ACTIVE)
print(user)
## User(id=1, name='Alice', status=<Status.ACTIVE:
## 'active'>)
```

### Combining Dataclasses with Protocols

```python
# dataclasses_and_protocols.py
from dataclasses import dataclass
from typing import Protocol


class Identifiable(Protocol):
    id: int


@dataclass
class User:
    id: int
    name: str


@dataclass
class Product:
    id: int
    price: float


def print_id(entity: Identifiable) -> None:
    print(f"ID: {entity.id}")


print_id(User(1, "Alice"))
## ID: 1
print_id(Product(101, 19.99))
## ID: 101
```

### Domain-Driven Design (DDD)

Define domain entities explicitly to enhance domain logic expressiveness:

```python
# ddd.py
from dataclasses import dataclass
from typing import List, NamedTuple


class Product(NamedTuple):
    name: str
    price: float


@dataclass
class Order:
    order_id: int
    products: List[Product]

    def total(self) -> float:
        return sum(product.price for product in self.products)
```

Strongly-typed domain models help catch issues early, facilitating clearer, safer, and more maintainable codebases.
