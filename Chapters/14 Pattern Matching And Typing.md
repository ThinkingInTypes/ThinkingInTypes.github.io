# Pattern Matching And Typing

> This placeholder text was generated by ChatGPT 4.5.
> It will be significantly rewritten as the book is developed.
> In the meantime you can add comments to either <https://bsky.app/bruceeckel> or [Github Issues](https://github.com/ThinkingInTypes/ThinkingInTypes.github.io/issues).

## Introduction to Structural Pattern Matching (Python 3.10+)

Python 3.10 introduced structural pattern matching, providing powerful and concise syntax to match objects against specific patterns:

```python
# example_1.py
def handle_command(command: str) -> str:
    match command:
        case "start":
            return "Starting"
        case "stop":
            return "Stopping"
        case _:
            return "Unknown command"
```

Pattern matching enhances readability and maintainability, reducing the complexity of conditional logic.

## Annotating Code with Pattern Matching

Annotations can clarify patterns used in structural matching, making code clearer and aiding static type checking:

```python
# example_2.py
from typing import Union

class Success:
    def __init__(self, result: str):
        self.result = result

class Error:
    def __init__(self, error: str):
        self.error = error

def process(response: Union[Success, Error]) -> str:
    match response := response:
        case Success(result=result):
            return f"Success: {result}"
        case Error(error):
            return f"Error: {error}"
```

This use of annotations and pattern matching simplifies complex decision-making logic.

## Annotating Code with Pattern Matching

When combining type annotations with pattern matching, carefully structuring types enhances type checker effectiveness:

### Example with TypedDict and Pattern Matching

```python
# example_3.py
from typing import TypedDict

class Command(TypedDict):
    action: str
    payload: dict

def process_command(command: TypedDict) -> None:
    match command:
        case {"action": "create", "item": item}:
            print(f"Creating {item}")
        case {"action": "delete", "id": int() as item_id}:
            print(f"Deleting item {item_id}")
        case _:
            print("Unknown command")
```

Annotations clearly define expected data shapes, improving readability and correctness.

## Type Checking Considerations with `match` Statements

Static type checkers can analyze pattern matching effectively, but careful type design is essential:

### Ensuring Consistent Patterns

Pattern matching works best with clearly annotated and structurally consistent types:

```python
# example_4.py
from typing import Union

class Cat:
    def meow(self) -> str:
        return "Meow"

class Dog:
    def bark(self) -> str:
        return "Woof"

def animal_sound(animal: Union[Cat, Dog]) -> str:
    match animal:
        case Cat():
            return animal.meow()
        case Dog():
            return animal.bark()
```

Properly annotated unions simplify handling of multiple types with clarity and safety.

## Real-world Scenarios for Pattern Matching

Pattern matching is highly effective in real-world scenarios, such as:

### Handling API Responses

```python
# example_5.py
def process_response(response: dict) -> str:
    match response:
        case {"status": "success", "data": data}:
            return f"Success: {data}"
        case {"status": "error", "message": error_msg}:
            return f"Error: {error}"
        case _:
            return "Unknown response format"
```

### Parsing Complex Data Structures

```python
# example_6.py
def parse_coordinates(coords: tuple) -> str:
    match coords := coords:
        case (float(lat), float(lon)):
            return f"Latitude: {lat}, Longitude: {lon}"
        case _:
            return "Invalid coordinates"
```

Pattern matching simplifies conditional logic, making code more maintainable.

## Type Checking Considerations

Ensure type annotations match patterns closely, as type checkers use them to validate correctness:

- Explicitly define type annotations for better static analysis.
- Carefully match patterns to annotated types for enhanced safety.

Properly using pattern matching alongside type annotations helps catch potential runtime errors early, resulting in safer and more readable Python code.
