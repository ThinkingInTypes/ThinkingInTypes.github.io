
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://ThinkingInTypes.github.io/C02B_Smalltalk_types/">
      
      
      
      
      <link rel="icon" href="../img/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.8">
    
    
      
        <title>"Type" in Smalltalk: A Dynamic, Message--Driven Perspective - Thinking in Types</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8608ea7d.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#type-in-smalltalk-a-dynamic-message-driven-perspective" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Thinking in Types" class="md-header__button md-logo" aria-label="Thinking in Types" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Thinking in Types
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              "Type" in Smalltalk: A Dynamic, Message--Driven Perspective
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ThinkingInTypes/ThinkingInTypes.github.io" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Thinking in Types" class="md-nav__button md-logo" aria-label="Thinking in Types" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Thinking in Types
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ThinkingInTypes/ThinkingInTypes.github.io" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C01_Preface/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1: Preface
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C02_Foundations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2: Foundations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C03_What_is_a_Type/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3: What is a Type
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C04_Using_Types/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4: Using Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C05_Custom_Types/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    5: Custom Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C06_Immutability/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    6: Immutability
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C07_Pattern_Matching/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    7: Pattern Matching
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C08_Generics/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    8: Generics
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C09_Callables/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    9: Callables
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C10_Structural_Typing/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    10: Structural Typing
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C11_Make_Illegal_Types_Unrepresentable/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    11: Make Illegal Types Unrepresentable
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C12_Errors_as_Values/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    12: Errors as Values
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../C13_Uncategorized_Topics/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    13: Uncategorized Topics
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z01_Appendix_Quick_Reference/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A1: Quick Reference
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z02_Appendix_Guidelines/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A2: Guidelines
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z03_Appendix_Type_Checkers/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A3: Type Checkers
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z04_Appendix_Automatic_Annotations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A4: Automatic Annotations
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z05_Appendix_Class_Attributes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A5: Class Attributes
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z06_Appendix_Tools/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A6: Tools
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z07_Appendix_Book_Utilities/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A7: Book Utilities
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z08_Appendix_Book_Notes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A8: Book Notes
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Z09_Appendix_Reference/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    A9: Reference
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#type-as-an-emergent-set-of-behaviors-duck-typing" class="md-nav__link">
    <span class="md-ellipsis">
      "Type" as an Emergent Set of Behaviors (Duck Typing)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#handling-the-unknown-doesnotunderstand" class="md-nav__link">
    <span class="md-ellipsis">
      *Handling the Unknown: doesNotUnderstand:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes-as-behavioral-templates-not-compile-time-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Classes as Behavioral Templates, Not Compile-Time Constraints
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#living-with-dynamic-typing-the-programmers-experience" class="md-nav__link">
    <span class="md-ellipsis">
      Living with Dynamic Typing: The Programmer's Experience
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#contrast-with-the-static-typing-mindset" class="md-nav__link">
    <span class="md-ellipsis">
      Contrast with the Static Typing Mindset
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion-the-philosophical-takeaway" class="md-nav__link">
    <span class="md-ellipsis">
      Conclusion: The Philosophical Takeaway
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="type-in-smalltalk-a-dynamic-message-driven-perspective">"Type" in Smalltalk: A Dynamic, Message--Driven Perspective<a class="headerlink" href="#type-in-smalltalk-a-dynamic-message-driven-perspective" title="Permanent link">#</a></h1>
<p>In Smalltalk, an object's identity and capabilities are not described by an explicit static type annotation.
Instead, an object is defined by the messages it can respond to.
In other words, an object's protocol--the collection of message selectors (methods) it understands--is effectively its "type."
You determine what an object can do by the messages you send it and how it responds, not by checking a formal static type label.</p>
<p>This message-centric view is fundamental to the Smalltalk experience.
All computation in Smalltalk is performed by sending messages to objects.
There are no free functions or primitive operations outside of this model--every operation is a message sent to some object.
The result of a message depends entirely on the receiver object: the same message selector might do something completely different on another object because each class provides its own method for that message.
This means the object itself decides how to fulfill a request,
reinforcing the idea that what matters is the object's behavior (its responses to messages), not an external static description.</p>
<h2 id="type-as-an-emergent-set-of-behaviors-duck-typing">"Type" as an Emergent Set of Behaviors (Duck Typing)<a class="headerlink" href="#type-as-an-emergent-set-of-behaviors-duck-typing" title="Permanent link">#</a></h2>
<p>Because there are no declared types on variables or method arguments in Smalltalk, the concept of "type" becomes an emergent property of an object's behavior.
A Smalltalk object's type can be thought of as "the set of messages to which an object can meaningfully respond."
In modern parlance, this is essentially duck typing--"if it walks like a duck and quacks like a duck, it's a duck."
Smalltalkers don't ask "Is this object of type Duck?"--there is no formal type check or interface to query.
Instead, they ask *"Can this object respond to the messages we associate with a duck (like <code>quack</code>or <code>swim</code>)?".
If yes, then for all intents and purposes, it can play the role of a duck in the program.
Different classes can implement the same set of messages, thereby effectively conforming to the same "duck type."
This gives Smalltalk tremendous flexibility and polymorphism--any object that implements the expected messages can be used in a given context, regardless of its class.</p>
<p>It's important to note that Smalltalk is not "weakly typed" or "untyped."
It is in fact strongly typed at runtime--if you send a message an object doesn't understand, the system will throw a runtime error rather than blindly misinterpreting it.
Strong typing only means type errors are prevented; it does not require that they be prevented at compile time.
Smalltalk enforces type safety dynamically: a <code>MessageNotUnderstood</code> error will halt a misuse, analogous to a type error in a static system, but occurring at runtime.
Thus, every object has a type in the sense of a well-defined set of messages/methods; what Smalltalk lacks is a static type checker to verify those at compile time.
A value's type is an intrinsic property of the object (determined by its class and methods) and not of the variable referencing it.
Any variable can refer to any object, so the "type" lives with the object, not the variable.
This is a form of optimistic typing--the system trusts the programmer to send appropriate messages and will dynamically prevent or flag errors if the trust is violated.</p>
<h2 id="handling-the-unknown-doesnotunderstand">*Handling the Unknown: <code>doesNotUnderstand:</code><a class="headerlink" href="#handling-the-unknown-doesnotunderstand" title="Permanent link">#</a></h2>
<p>One fascinating aspect of Smalltalk's message-centric design is how it handles an unknown message.
If you send an object a message for which it has no defined method, the runtime doesn't immediately crash.
Instead, it sends a special message <code>doesNotUnderstand:</code> to that object, passing along a description of the original message.
By default, <code>Object&gt;&gt;doesNotUnderstand:</code> will raise a <code>MessageNotUnderstood</code> error (often opening a debugger in a Smalltalk IDE),
but critically, developers can override this method to change the behavior.
This means an object can be designed to gracefully handle any message at all, even ones not originally defined in its class's method dictionary.</p>
<p>For example, one could create a proxy object that intercepts all messages via <code>doesNotUnderstand:</code> and forwards them to another object,
or a stub that logs all unknown messages for testing.
In fact, Smalltalk was the first language to introduce this kind of open-ended message handling, and it unlocks a lot of power.
Using <code>doesNotUnderstand:</code>, programmers have implemented features like remote method invocation proxies,
lazy-loaded objects, futures, and other patterns that require catching arbitrary messages at runtime.
The existence of <code>doesNotUnderstand:</code> underscores that an object's "type" (its message-handling ability) isn't necessarily fixed by its class--it can be extended or altered at runtime in a very dynamic fashion.
Thanks to this mechanism, an object can respond to a message without considering when it was written.
From a philosophical view, this pushes the "duck typing" idea to the extreme: an object can choose to attempt anything asked of it,
defining its behavior on the fly.</p>
<p>The flip side is that you truly don't know if a given message will be handled until you send it.
In practice, Smalltalk programmers cope with this by testing and by building systems where the expectations are clear
(or by using the interactive tools to inspect an object's class/protocol).
But it does raise an interesting question: if the only way to know what an object can do is to try it
and see, can we really say the object "has a type" in the same sense as in a statically typed language?
The answer in Smalltalk is that type is a dynamic notion--it's something an object does, not something it declares.
The object's type manifests when a message is sent and successfully understood.
If it isn't, that's effectively a type mismatch, caught by the runtime (often during development in the live environment).</p>
<h2 id="classes-as-behavioral-templates-not-compile-time-constraints">Classes as Behavioral Templates, Not Compile-Time Constraints<a class="headerlink" href="#classes-as-behavioral-templates-not-compile-time-constraints" title="Permanent link">#</a></h2>
<p>Smalltalk is a class-based OO language, and every object is an instance of some class.
However, a class in Smalltalk is not a "type" in the static sense; it's more like a template that defines behavior and structure.
A class specifies which messages its instances will understand (by providing method implementations for those messages), and it defines the internal state structure.
Two different classes could end up implementing the same protocol (thus effectively the same behavioral
type), but they would still be distinct classes (perhaps with different internal representations).
The Smalltalk system doesn't have a separate notion of an interface or protocol type distinct from classes--classes are how you organize and advertise what messages exist.
But importantly, the system will never restrict you to using only a particular class in a given variable or call.
There's no static type checker insisting "this variable must contain an instance of class X."
The class is a property of the object itself, not a restriction on its use by others.</p>
<p>In the Smalltalk programmer's mind, classes serve as a useful guide and documentation of an object's capabilities, but not a rigid cage.
They provide a shared vocabulary of messages
for all instances of that class (and subclasses), which helps humans reason about what an object can do.
For example, if you have a <code>GraphicsShape</code> class with methods like <code>drawOn:</code>,
<code>area</code>, etc., you know any instance of that class (or its subclasses) will respond to those messages.
In day-to-day practice, a Smalltalk developer
does often think in terms of an object's class when reasoning about what messages it can handle--the class system is the primary organizational tool for behavior.
But this is a convention and convenience, not an enforcement mechanism.
You could always substitute an object of a completely different class in a piece of code, as long as it implements the needed messages.
The Smalltalk environment even allows adding methods to classes at runtime or creating entirely new classes on the fly, which means the system's notion of who can respond to what is always
malleable.
Classes thus shape an object's behavior, but they do not constitute a static contract imposed on the rest of the program.</p>
<p>It's illuminating to compare this with how statically typed languages use classes.
In a language like Java or C++, a class (or an interface) is treated as a type contract.
Programmers in those languages think of types as a form of guarantee or enforcement:
if a variable is declared of interface type <code>Drawable</code>,
the compiler guarantees it can only ever hold objects that implement the <code>draw()</code> method
(and will refuse to compile code that tries to call a non-existent method or assign an incompatible type).
Types in statically typed languages act
like promises enforced by the compiler--they delineate what you can and cannot do at compile time.
They also function as explicit documentation: you read a function signature and see exactly what types it accepts/returns, shaping your expectations.
Many developers in static systems conceptualize a type as a contractual
specification of an object's interface (sometimes even enriched with static checks for invariants, generics, etc., as the "shape" of data).</p>
<p>In Smalltalk, by contrast, a class is not a promise to the compiler (since there is no compile-time type checking).
It's more a description for the programmer and a container of methods.
The "contract" in Smalltalk is informal and psychological: you are expected to pass objects that will do the right thing.
If you violate that expectation, the system will tell you at runtime.
Thus, the mental model shifts from "I have a guarantee this object supports X, Y, Z operations" to
"I believe (or have tested) that this object supports X, Y, Z--and if I'm wrong, I'll find out when I run the code."
The class of the object is a strong hint (since class defines the methods), but it's not an enforced boundary.
Indeed, a seasoned Smalltalker might say an object's true "type" is simply the set of messages it knows how to
handle, regardless of its class name.
The class is one way to know that set, but it's not the only way--you could also query the object at runtime (ask it <code>respondsTo:</code> a certain selector) or consult documentation/tests.</p>
<h2 id="living-with-dynamic-typing-the-programmers-experience">Living with Dynamic Typing: The Programmer's Experience<a class="headerlink" href="#living-with-dynamic-typing-the-programmers-experience" title="Permanent link">#</a></h2>
<p>The day-to-day experience of programming in Smalltalk is very dynamic and interactive, which affects how one thinks about types.
In a static language, you often plan out type hierarchies and use the compiler as a tool to catch mistakes early.
In Smalltalk, you rely on a combination of clear design, tests, and the interactive environment to ensure objects are used appropriately.
For example, you might write a method that expects "an object that can print itself."
You won't declare a type, but you'll likely name the parameter suggestively (e.g. <code>anObject</code> or <code>aPrintable</code>) and maybe mention in a comment that it should respond to <code>printOn:</code>.
When using that method, you ensure you pass something like a String or a Number (classes that you know implement <code>printOn:</code>).
There is a lot of trust and convention involved--but it's trust backed by the ability to quickly try things out in the live environment.</p>
<p>Smalltalk's development environment is a persistent image of objects, where you can test sending messages in a Workspace or inspect an object's class and methods on the fly.
This means that if you're unsure about what messages an object supports, you can literally ask the object or its class at runtime.
The system can list an object's method selectors or let you browse its class hierarchy.
This introspective capability (made possible because everything is alive in the image) gives you a form of "live documentation."
A Smalltalk system is an ecosystem of live objects.
You can query the running program directly, rather than rely solely on static type information.</p>
<p>When you make a mistake--say you send a message an object doesn't understand--it's not usually a silent failure.
In a typical Smalltalk IDE, a debugger pops up at the point of error (the MessageNotUnderstood).
This is not just an error message; it's an opportunity.
You can inspect the actual object that failed (seeing its class and state), figure out why it didn't have the method, and often even
define the missing method right there in the debugger and continue execution.
This exemplifies the "lived" experience: the program is malleable and can be fixed or extended on the fly.
The boundary of what an object's "type" is can literally be extended during runtime by adding a new method to its class (or by implementing
<code>doesNotUnderstand:</code> to catch that message next time).
Such dynamism is foreign to statically typed environments but is natural in Smalltalk's philosophy.
It emphasizes that software is fluid--an object's behavior (hence its type) can evolve as the program runs.</p>
<p>From a philosophical standpoint, a Smalltalk programmer tends to think in terms of objects and messages first, and types (in the classical sense) hardly at all.
Alan Kay, the father of Smalltalk, famously remarked that "OOP to me means only messaging, local retention and protection and hiding
of state-process, and extreme late-binding of all things."
(Late-binding here refers to deciding at run-time what method to invoke for a given message--precisely what dynamic typing entails.) This mindset puts the focus on behavior rather than classification.
If you ask a Smalltalker "what type is this object?" they are likely to answer in terms of its class or its responsibilities (e.g.
"this is a kind of stream object--it can next/nextPut: etc.").
They wouldn't typically enumerate a static type name with a fixed interface contract because that's not how the language frames the discussion.</p>
<p>All you can do with any object is send it a message and observe the result; therefore, conceptually, "type" is just a description of those results you can expect.</p>
<h2 id="contrast-with-the-static-typing-mindset">Contrast with the Static Typing Mindset<a class="headerlink" href="#contrast-with-the-static-typing-mindset" title="Permanent link">#</a></h2>
<p>To crystallize the differences, it helps to compare the Smalltalk approach with how statically typed language programmers think about types:</p>
<p>Types as Explicit Contracts (Static Languages): In a static language (Java, C#, Haskell, etc.), a type is an explicit contract or
blueprint for both the compiler and the programmer.
For instance, an interface in Java might guarantee that anything of that interface type has certain methods.
The programmer leans on the compiler to enforce that contract--calling a non-existent method or violating type expectations is caught at compile time.
This often leads to designing software by starting with type definitions (classes/interfaces) that model the problem domain and using those as
constraints* to prevent incorrect usage.
Types also serve as documentation: you know a function <code>foo(Vector v)</code> requires a <code>Vector</code> and you know exactly what a <code>Vector</code> can do (from its class/interface definition).
There's comfort (and some rigidity) in this; you can't accidentally call
<code>v.turnPurple()</code> on a <code>Vector</code> if that method isn't in its type.
But you also can't pass a <code>Matrix</code> to <code>foo</code> unless <code>Matrix</code> is declared to be a subclass or implementer of <code>Vector</code>--even if
<code>Matrix</code> happens to support all the same operations needed, the static type system will reject it if it's not formally declared compatible.</p>
<ul>
<li>Types as Descriptions of Behavior (Smalltalk): In Smalltalk, types are not explicit labels but implicit descriptions of behavior.
  If a method expects a "duck-like" object, you simply pass it an object and trust it knows how to quack; there is no
  <code>IDuck</code> interface to check against.
  As long as the object can handle the messages used inside the method, it works--otherwise a runtime error occurs.
  This is often called "programming by wishful
  thinking" or optimistic coding: you code as if the object will do what you want, and usually your design ensures it will.
  In cases where you want to be cautious, you might do a runtime check (using <code>object respondsTo: #quack</code> or an
  <code>isKindOf:</code> check), but ideally polymorphism makes that unnecessary.
  The emphasis is on what an object can do, not what it is declared to be.
  The result is a very flexible system: any object that meets the behavioral expectations can be used, even if it wasn't originally anticipated.
  There is no need to cast or to adapt types to match an exact signature--the message itself is the only requirement.
  This is why Smalltalk (and languages like it) enable a style where
  "if it quacks like a duck, it's a duck."
  The trade-off is that mistakes show up at runtime, so thorough testing and a good suite of examples are essential to gain confidence in the code's correctness.</li>
</ul>
<p>Classes vs. Types: Smalltalk's classes fill some of the same roles as static types (grouping objects with similar behavior,
giving a name to a set of methods), but they are not used as a compile-time gatekeeper.
They are more for the programmer's organization and the runtime method lookup.
In statically typed languages, you often have distinct concepts of "class vs interface vs type parameter," etc., which are all part of the type system.
Smalltalk collapses much of that--a class is essentially a concrete implementation and
potentially* also the description of a protocol, but there's nothing like a separately declared interface.
So a Smalltalk programmer might think "this object is a kind of OrderedCollection because it's an instance of that class, so it supports all the collection messages."
But they are also free to pass in any other object that honors the same messages (even if it's not a
<code>OrderedCollection</code> subclass) to code that was written with <code>OrderedCollection</code> in mind.
The flexibility is higher, though the guarantee is only verified when the code actually runs.</p>
<p>In summary, programmers in statically typed languages often view types as static contracts or enforcement mechanisms, whereas Smalltalk programmers view types more as emergent properties of objects.
The Smalltalker's mindset is shaped by a live, message-oriented world where you gain understanding by sending messages and watching objects behave.
It's a very experience-driven understanding of type: an object "proves" its type by working correctly in response to your messages,
not by satisfying a compiler check ahead of time.
This can be incredibly liberating--it encourages focusing on what needs to happen in the problem domain,
letting different kinds of objects participate as long as they behave appropriately.
As the Smalltalk ethos would suggest, "Look at what the object does, not what it says it is."</p>
<h2 id="conclusion-the-philosophical-takeaway">Conclusion: The Philosophical Takeaway<a class="headerlink" href="#conclusion-the-philosophical-takeaway" title="Permanent link">#</a></h2>
<p>From a practical and philosophical perspective, "type" in Smalltalk is less a label and more a dynamic quality of an object's behavior.
It's defined by the messages an object understands and how it responds, which is ultimately determined by its class's methods (and any clever
<code>doesNotUnderstand:</code> tricks).
An object can certainly be said to "have a type" in Smalltalk--but that type isn't a static tag; it's the set of messages it can handle,
i.e., its protocol.
Smalltalk's class system provides the structure for those protocols (acting as a template for behavior),
but it doesn't impose the sort of strict borders that static type systems do.
Instead of types as fences that keep misuse at bay, Smalltalk offers open pastures
where objects roam freely as long as they know how to handle the interactions (messages) that come their way.</p>
<p>The lived Smalltalk experience is one of constant discovery and feedback: you send a message and see what happens.
This leads to a very concrete understanding of an object's capabilities--you gain knowledge of its "type" by observing it in action.
Philosophically, this shifts the notion of type from an abstract compile-time idea to a tangible runtime reality.
Rather than trust a compiler's assurances, you come to trust the objects themselves (and your tests of them).
Smalltalk's message-driven worldview teaches that an object is exactly what it does.
By emphasizing messaging and late binding, it reminds us that software is ultimately about dynamic interactions.
In statically typed systems, type is often treated as essence; in Smalltalk, type is experience.
The result is a programming model that is highly flexible, deeply object-oriented,
and rooted in the immediate reality of message sends--a model where the concept of "type" lives not in declarations,
but in the rich interplay between objects at runtime.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy", "content.code.select", "navigation.indexes"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>