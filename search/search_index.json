{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Thinking in Types","text":"<p>by Bruce Eckel</p>"},{"location":"#building-stubbornly-resilient-python-code","title":"Building Stubbornly Resilient Python Code","text":""},{"location":"01%20Preface/","title":"Preface","text":""},{"location":"02%20Introduction/","title":"Introduction","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"02%20Introduction/#dynamic-vs-static-typing-definitions-pros-and-cons","title":"Dynamic vs. Static Typing: Definitions, Pros, and Cons","text":"<p>Python is traditionally known as a dynamically typed language. This means the types of variables are determined at runtime rather than explicitly declared. For example:</p> <pre><code># example_1.py\nx = 42      # x is dynamically assigned as an integer\ny = \"hello\" # y is dynamically assigned as a string\n</code></pre> <p>In contrast, statically typed languages require explicit type declarations, and types are checked at compile time:</p> <pre><code>int x = 42;       // Java explicitly defines x as an integer\nString y = \"hello\"; // Java explicitly defines y as a String\n</code></pre> <p>Pros of dynamic typing:</p> <ul> <li>Faster prototyping and development</li> <li>Greater flexibility in handling different types</li> <li>Easier learning curve for beginners</li> </ul> <p>Cons of dynamic typing:</p> <ul> <li>Runtime type errors can occur unexpectedly</li> <li>Less clarity on expected data types</li> <li>Reduced safety and predictability</li> </ul> <p>Pros of static typing:</p> <ul> <li>Type errors caught early at compile time</li> <li>Enhanced code clarity and readability</li> <li>Improved performance and optimization opportunities</li> </ul> <p>Cons of static typing:</p> <ul> <li>Verbose code with explicit declarations</li> <li>Potentially slower initial development</li> <li>Steeper learning curve for newcomers</li> </ul>"},{"location":"02%20Introduction/#pythons-typing-evolution-from-duck-typing-to-type-annotations","title":"Python's Typing Evolution: From Duck Typing to Type Annotations","text":"<p>Python initially embraced the concept of \"duck typing,\" where the suitability of an object is determined by the presence of methods and properties, not by its explicit type. If it looks like a duck and quacks like a duck, it's treated as a duck:</p> <pre><code># example_2.py\nclass Duck:\n    def quack(self):\n        print(\"Quack!\")\n\ndef make_it_quack(bird):\n    bird.quack()\n\nmake_it_quack(Duck())  # works fine\n</code></pre> <p>However, as Python projects grew in scale and complexity, the need for type safety and clearer documentation became apparent. Python 3.5 introduced type annotations, allowing developers to optionally specify expected types:</p> <pre><code># example_3.py\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n</code></pre> <p>This evolution combines the best of both worlds\u2014maintaining Python's flexibility while adding optional type safety.</p>"},{"location":"02%20Introduction/#benefits-of-type-annotations-maintainability-readability-safety","title":"Benefits of Type Annotations: Maintainability, Readability, Safety","text":""},{"location":"02%20Introduction/#maintainability","title":"Maintainability","text":"<ul> <li>Clearly defined types make code easier to refactor and maintain over time.</li> <li>Reduces uncertainty about the intended use of variables and functions.</li> </ul>"},{"location":"02%20Introduction/#readability","title":"Readability","text":"<ul> <li>Type annotations serve as inline documentation.</li> <li>Quickly communicates developer intentions to other team members.</li> </ul>"},{"location":"02%20Introduction/#safety","title":"Safety","text":"<ul> <li>Catch errors early, before the program runs.</li> <li>Reduces runtime exceptions due to unexpected types.</li> </ul>"},{"location":"02%20Introduction/#type-checking-tools-overview-mypy-pyright-pycharm","title":"Type Checking Tools Overview (<code>mypy</code>, <code>pyright</code>, PyCharm)","text":"<p>Python\u2019s ecosystem provides robust tools to leverage type annotations:</p>"},{"location":"02%20Introduction/#mypy","title":"mypy","text":"<ul> <li>One of the earliest static type checkers for Python.</li> <li>Highly configurable and widely adopted.</li> </ul> <pre><code>pip install mypy\nmypy your_script.py\n</code></pre>"},{"location":"02%20Introduction/#pyright","title":"pyright","text":"<ul> <li>Developed by Microsoft, emphasizing performance and ease of use.</li> <li>Built into VSCode, offering real-time feedback.</li> </ul> <pre><code>npm install -g pyright\npyright your_script.py\n</code></pre>"},{"location":"02%20Introduction/#pycharm","title":"PyCharm","text":"<ul> <li>Integrated IDE support for type checking.</li> <li>Provides immediate visual feedback as you write code.</li> </ul> <p>These tools allow developers to incrementally adopt static typing, improving code reliability without sacrificing Python's dynamic roots.</p>"},{"location":"02%20Introduction/#understanding-runtime-vs-static-type-checking","title":"Understanding Runtime vs. Static Type Checking","text":""},{"location":"02%20Introduction/#runtime-type-checking","title":"Runtime Type Checking","text":"<ul> <li>Types are validated as the program executes.</li> <li>Errors surface only when problematic code is executed.</li> </ul> <pre><code># example_4.py\ndef add(a, b):\n    return a + b\n\nadd(1, \"2\")  # raises runtime TypeError\n</code></pre>"},{"location":"02%20Introduction/#static-type-checking","title":"Static Type Checking","text":"<ul> <li>Performed before the code runs, typically during development or as part of CI/CD pipelines.</li> <li>Prevents many type-related errors by analyzing code structure.</li> </ul> <pre><code># example_5.py\n# mypy detects this error before running\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\nadd(1, \"2\")  # Static type checker flags this\n</code></pre> <p>By combining runtime flexibility with static checking, Python provides a balanced approach that empowers developers to write safe, readable, and maintainable code.</p>"},{"location":"03%20Basic_Annotations/","title":"Basic Annotations","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"03%20Basic_Annotations/#annotating-built-in-types-int-str-float-bool-none","title":"Annotating Built-in Types (<code>int</code>, <code>str</code>, <code>float</code>, <code>bool</code>, <code>None</code>)","text":"<p>Python supports type annotations for its fundamental built-in types, allowing developers to clarify expected types of variables and function arguments explicitly:</p> <pre><code># example_1.py\nage: int = 25\nname: str = \"Alice\"\nsalary: float = 45000.50\nis_active: bool = True\nno_value: None = None\n</code></pre> <p>These annotations immediately communicate intent, simplifying code readability and maintainability.</p>"},{"location":"03%20Basic_Annotations/#annotating-variables-and-functions","title":"Annotating Variables and Functions","text":"<p>Type annotations can be added to variables and function parameters to indicate expected data types:</p>"},{"location":"03%20Basic_Annotations/#variables","title":"Variables","text":"<pre><code># example_2.py\nuser_id: int = 123\nusername: str = \"admin\"\n</code></pre>"},{"location":"03%20Basic_Annotations/#functions","title":"Functions","text":"<pre><code># example_3.py\ndef greet_user(username: str) -&gt; str:\n    return f\"Welcome, {username}!\"\n</code></pre> <p>Annotations clearly specify expected input and output types, helping prevent bugs and errors.</p>"},{"location":"03%20Basic_Annotations/#optional-types-and-default-values","title":"Optional Types and Default Values","text":"<p>Sometimes a variable or function argument can be a specific type or <code>None</code>. Python uses <code>Optional</code> from <code>typing</code> to indicate this:</p> <pre><code># example_4.py\nfrom typing import Optional\n\ndef find_user(user_id: int) -&gt; Optional[str]:\n    if user_id == 1:\n        return \"Alice\"\n    return None\n</code></pre> <p>Default values with optional annotations:</p> <pre><code># example_5.py\ndef greet(name: Optional[str] = None) -&gt; str:\n    if name:\n        return f\"Hello, {name}!\"\n    return \"Hello!\"\n</code></pre>"},{"location":"03%20Basic_Annotations/#using-union-types-operator-vs-union","title":"Using Union Types (<code>|</code> operator vs. <code>Union</code>)","text":"<p>Python allows you to specify multiple acceptable types for variables or parameters. Traditionally, the <code>Union</code> type was used, but Python 3.10 introduced the <code>|</code> operator for readability:</p>"},{"location":"03%20Basic_Annotations/#using-union","title":"Using <code>Union</code>","text":"<pre><code># example_6.py\nfrom typing import Union\n\ndef process_value(value: Union[int, str]) -&gt; str:\n    return str(value)\n</code></pre>"},{"location":"03%20Basic_Annotations/#using-operator-python-310","title":"Using <code>|</code> operator (Python 3.10+)","text":"<pre><code># example_7.py\ndef process_value(value: int | str) -&gt; str:\n    return str(value)\n</code></pre> <p>The <code>|</code> operator provides clearer and more concise syntax.</p>"},{"location":"03%20Basic_Annotations/#defining-type-aliases","title":"Defining Type Aliases","text":"<p>Type aliases simplify complex annotations by providing a readable and reusable name for a type:</p> <pre><code># example_8.py\nfrom typing import List\n\nUserIDs = List[int]\n\ndef process_users(user_ids: UserIDs) -&gt; None:\n    for uid in user_ids:\n        print(f\"Processing user {uid}\")\n</code></pre> <p>Aliases improve code clarity, especially for complex types.</p>"},{"location":"03%20Basic_Annotations/#common-annotation-patterns-and-errors","title":"Common Annotation Patterns and Errors","text":""},{"location":"03%20Basic_Annotations/#common-patterns","title":"Common Patterns","text":"<ul> <li>Clearly annotate function parameters and return values.</li> <li>Use type aliases for complex or repetitive types.</li> <li>Use optional annotations when values can legitimately be <code>None</code>.</li> </ul>"},{"location":"03%20Basic_Annotations/#common-errors","title":"Common Errors","text":"<ul> <li>Incorrect annotations (e.g., annotating as <code>int</code> when the value might be <code>float</code>).</li> <li>Missing annotations on important public APIs or interfaces.</li> <li>Overuse of overly broad types like <code>Any</code>, reducing annotation benefits.</li> </ul> <p>Example error:</p> <pre><code># example_9.py\ndef calculate_area(radius: int) -&gt; float:\n    return 3.14 * radius ** 2\n\ncalculate_area(3.5)  # Error detected by static type checkers\n</code></pre> <p>Careful use of annotations combined with static checking tools significantly enhances code robustness and readability.</p>"},{"location":"04%20Collections/","title":"Collections","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"04%20Collections/#annotating-lists-tuples-sets-dictionaries","title":"Annotating Lists, Tuples, Sets, Dictionaries","text":"<p>Python provides built-in collection types such as lists, tuples, sets, and dictionaries. Annotating these clearly specifies their expected contents:</p>"},{"location":"04%20Collections/#lists","title":"Lists","text":"<pre><code># example_1.py\nfrom typing import List\n\nscores: List[int] = [95, 85, 75]\n</code></pre>"},{"location":"04%20Collections/#tuples","title":"Tuples","text":"<pre><code># example_2.py\nfrom typing import Tuple\n\ncoordinates: Tuple[float, float] = (23.5, 45.8)\n</code></pre>"},{"location":"04%20Collections/#sets","title":"Sets","text":"<pre><code># example_3.py\nfrom typing import Set\n\nunique_ids: Set[str] = {\"abc\", \"xyz\", \"123\"}\n</code></pre>"},{"location":"04%20Collections/#dictionaries","title":"Dictionaries","text":"<pre><code># example_4.py\nfrom typing import Dict\n\nuser_data: Dict[str, int] = {\"Alice\": 30, \"Bob\": 25}\n</code></pre> <p>These annotations enhance readability and help catch type-related errors early.</p>"},{"location":"04%20Collections/#annotations-without-imports","title":"Annotations without Imports","text":"<p>Starting from Python 3.9, built-in collection types support direct annotations without importing from <code>typing</code>:</p> <pre><code># example_5.py\nscores: list[int] = [95, 85, 75]\nuser_data: dict[str, float] = {\"Alice\": 95.5, \"Bob\": 85.3}\n</code></pre> <p>This simplified syntax enhances readability and reduces verbosity.</p>"},{"location":"04%20Collections/#specialized-annotations-sequence-mapping-iterable-iterator","title":"Specialized Annotations (<code>Sequence</code>, <code>Mapping</code>, <code>Iterable</code>, <code>Iterator</code>)","text":"<p>Python provides specialized annotations for greater flexibility:</p>"},{"location":"04%20Collections/#sequence","title":"<code>Sequence</code>","text":"<ul> <li>For any ordered collection supporting indexing:</li> </ul> <pre><code># example_6.py\nfrom typing import Sequence\n\ndef average(numbers: Sequence[float]) -&gt; float:\n    return sum(numbers) / len(numbers)\n</code></pre>"},{"location":"04%20Collections/#mapping","title":"<code>Mapping</code>","text":"<ul> <li>For dictionary-like objects:</li> </ul> <pre><code># example_7.py\nfrom typing import Mapping\n\ndef get_user_age(users: Mapping[str, int], username: str) -&gt; int:\n    return users.get(username, 0)\n</code></pre>"},{"location":"04%20Collections/#iterable-and-iterator","title":"<code>Iterable</code> and <code>Iterator</code>","text":"<ul> <li>For looping over items:</li> </ul> <pre><code># example_8.py\nfrom typing import Iterable, Iterator\n\ndef print_items(items: Iterable[str]) -&gt; None:\n    for item in items:\n        print(item)\n\n\ndef generate_numbers(n: int) -&gt; Iterator[int]:\n    for i in range(n):\n        yield i\n</code></pre> <p>Specialized annotations enable broader compatibility with various collection types.</p>"},{"location":"05%20Generics/","title":"Generics","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"05%20Generics/#defining-custom-generics-with-typevar-and-generic","title":"Defining Custom Generics with <code>TypeVar</code> and <code>Generic</code>","text":"<p>Custom generics allow functions and classes to handle various types flexibly:</p>"},{"location":"05%20Generics/#using-typevar","title":"Using <code>TypeVar</code>","text":"<pre><code># example_1.py\nfrom typing import TypeVar, List\n\nT = TypeVar('T')\n\ndef first_item(items: List[T]) -&gt; T:\n    return items[0]\n\nprint(first_item([1, 2, 3]))  # returns int\nprint(first_item([\"a\", \"b\"]))  # returns str\n</code></pre>"},{"location":"05%20Generics/#generic-classes","title":"Generic Classes","text":"<pre><code># example_2.py\nfrom typing import Generic\n\nclass Box(Generic[T]):\n    def __init__(self, content: T):\n        self.content = content\n\nbox_int = Box(123)\nbox_str = Box(\"hello\")\n</code></pre> <p>Custom generics enhance code reusability and type safety.</p>"},{"location":"05%20Generics/#using-constraints-and-bounds-with-generics","title":"Using Constraints and Bounds with Generics","text":"<p>Generics can include constraints and bounds to restrict allowed types:</p>"},{"location":"05%20Generics/#constraints","title":"Constraints","text":"<pre><code># example_3.py\nU = TypeVar('U', int, float)\n\ndef add(a: U, b: U) -&gt; U:\n    return a + b\n\nadd(1, 2)      # valid\nadd(1.5, 2.5)  # valid\n# add(\"a\", \"b\")  # invalid, detected by type checker\n</code></pre>"},{"location":"05%20Generics/#bounds","title":"Bounds","text":"<pre><code># example_4.py\nclass Animal:\n    def speak(self) -&gt; str:\n        return \"...\"\n\nA = TypeVar('A', bound=Animal)\n\ndef animal_sound(animal: A) -&gt; str:\n    return animal.speak()\n\nclass Dog(Animal):\n    def speak(self) -&gt; str:\n        return \"Woof!\"\n\nprint(animal_sound(Dog()))  # \"Woof!\"\n</code></pre> <p>Constraints and bounds improve specificity in generic type annotations, enhancing code clarity and correctness.</p>"},{"location":"06%20Dataclasses/","title":"Dataclasses","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p> <p>(Insert material from Pycon presentation)</p>"},{"location":"06%20Dataclasses/#using-dataclasses-effectively","title":"Using Dataclasses Effectively","text":"<p>Dataclasses simplify class definitions by automatically generating methods like <code>__init__</code>, <code>__repr__</code>, and <code>__eq__</code>:</p> <pre><code># example_1.py\nfrom dataclasses import dataclass\n\n@dataclass\nclass Product:\n    name: str\n    price: float\n    in_stock: bool = True\n\nproduct = Product(\"Laptop\", 999.99)\nprint(product)  # Product(name='Laptop', price=999.99, in_stock=True)\n</code></pre> <p>Dataclasses reduce boilerplate, ensuring concise and readable class definitions.</p>"},{"location":"06%20Dataclasses/#advanced-dataclass-features","title":"Advanced Dataclass Features","text":"<p>Dataclasses support default factories, immutability, and more:</p> <pre><code># example_2.py\nfrom dataclasses import dataclass, field\nfrom typing import List\n\n@dataclass(frozen=True)\nclass Order:\n    order_id: int\n    items: List[str] = field(default_factory=list)\n\norder = Order(order_id=123)\n# order.order_id = 456  # Error: dataclass is frozen (immutable)\n</code></pre>"},{"location":"07%20Specialized_Type_Tools/","title":"Specialized Type Tools","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"07%20Specialized_Type_Tools/#misunderstanding-class-variables","title":"Misunderstanding Class Variables","text":"<p>Class annotations provide explicit type definitions for attributes and methods, increasing clarity and ensuring type consistency:</p> <pre><code># example_1.py\nclass User:\n    # Misunderstanding of class variables; add blog post here\n    # username: str\n    # age: int\n\n    def __init__(self, username: str, age: int):\n        self.username = username\n        self.age = age\n\n    def greet(self) -&gt; str:\n        return f\"Hello, {self.username}!\"\n</code></pre> <p>Annotations help document the intended use of class members and improve maintainability.</p>"},{"location":"07%20Specialized_Type_Tools/#typed-namedtuples-definition-and-use","title":"Typed NamedTuples: Definition and Use","text":"<p>Typed <code>NamedTuple</code> combines tuple immutability with type annotations and named fields:</p> <pre><code># example_2.py\nfrom typing import NamedTuple\n\nclass Coordinates(NamedTuple):\n    latitude: float\n    longitude: float\n\ncoords = Coordinates(51.5074, -0.1278)\nprint(coords.latitude)  # 51.5074\n</code></pre> <p><code>NamedTuple</code> provides clarity, immutability, and easy unpacking, ideal for simple structured data.</p>"},{"location":"07%20Specialized_Type_Tools/#leveraging-typeddicts-for-structured-data","title":"Leveraging TypedDicts for Structured Data","text":"<p><code>TypedDict</code> is useful when defining dictionary structures with known keys and typed values:</p> <pre><code># example_3.py\nfrom typing import TypedDict\n\nclass UserProfile(TypedDict):\n    username: str\n    email: str\n    age: int\n\nuser: UserProfile = {\"username\": \"alice\", \"email\": \"alice@example.com\", \"age\": 30}\n</code></pre> <p><code>TypedDict</code> clarifies expected keys and types, providing type safety for dictionary data.</p>"},{"location":"07%20Specialized_Type_Tools/#optional-fields-in-typeddict","title":"Optional Fields in TypedDict","text":"<p>You can specify optional fields using <code>NotRequired</code> (Python 3.11+) or <code>total=False</code>:</p> <pre><code># example_4.py\nfrom typing import TypedDict, NotRequired\n\nclass UserSettings(TypedDict):\n    theme: str\n    notifications_enabled: NotRequired[bool]\n\nsettings: UserSettings = {\"theme\": \"dark\"}\n</code></pre> <p>This flexibility allows clear definitions for complex, partially-optional data structures.</p>"},{"location":"07%20Specialized_Type_Tools/#patterns-for-strongly-typed-domain-models","title":"Patterns for Strongly-Typed Domain Models","text":"<p>Strongly-typed domain models help clearly represent domain logic, improving robustness and maintainability:</p>"},{"location":"07%20Specialized_Type_Tools/#using-dataclasses-and-enums","title":"Using Dataclasses and Enums","text":"<pre><code># example_5.py\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass Status(Enum):\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\"\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    status: Status\n\nuser = User(id=1, name=\"Alice\", status=Status.ACTIVE)\n</code></pre>"},{"location":"07%20Specialized_Type_Tools/#combining-dataclasses-with-protocols","title":"Combining Dataclasses with Protocols","text":"<pre><code># example_6.py\nfrom typing import Protocol\n\nclass Identifiable(Protocol):\n    id: int\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\n@dataclass\nclass Product:\n    id: int\n    price: float\n\ndef print_id(entity: Identifiable) -&gt; None:\n    print(f\"ID: {entity.id}\")\n\nprint_id(User(1, \"Alice\"))\nprint_id(Product(101, 19.99))\n</code></pre>"},{"location":"07%20Specialized_Type_Tools/#domain-driven-design-example","title":"Domain-driven Design Example","text":"<p>Define domain entities explicitly to enhance domain logic expressiveness:</p> <pre><code># example_7.py\n@dataclass\nclass Order:\n    order_id: int\n    products: List[Product]\n\n    def total_price(self) -&gt; float:\n        return sum(product.price for product in self.products)\n</code></pre> <p>Strongly-typed domain models help catch issues early, facilitating clearer, safer, and more maintainable codebases.</p>"},{"location":"08%20Callable_Types/","title":"Callable Types","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"08%20Callable_Types/#annotating-functions-and-lambdas","title":"Annotating Functions and Lambdas","text":"<p>Clearly annotating functions and lambda expressions improves readability and type safety:</p>"},{"location":"08%20Callable_Types/#function-annotations","title":"Function Annotations","text":"<pre><code># example_1.py\ndef add(x: int, y: int) -&gt; int:\n    return x + y\n</code></pre>"},{"location":"08%20Callable_Types/#lambda-annotations","title":"Lambda Annotations","text":"<p>Annotating lambdas directly isn't supported; however, annotations can be implied:</p> <pre><code># example_2.py\nfrom typing import Callable\n\nadder: Callable[[int, int], int] = lambda x, y: x + y\n</code></pre> <p>This explicit approach ensures that lambda behavior is type-checked properly.</p>"},{"location":"08%20Callable_Types/#using-callable-for-higher-order-functions","title":"Using <code>Callable</code> for Higher-Order Functions","text":"<p>The <code>Callable</code> type is essential for annotating functions that accept or return other functions:</p> <pre><code># example_3.py\nfrom typing import Callable\n\ndef operate(a: int, b: int, func: Callable[[int, int], int]) -&gt; int:\n    return func(a, b)\n\nresult = operate(5, 3, lambda x, y: x * y)  # returns 15\n</code></pre> <p>Using <code>Callable</code> clearly defines expected function signatures, enhancing maintainability and correctness.</p>"},{"location":"08%20Callable_Types/#advanced-function-annotations-with-paramspec","title":"Advanced Function Annotations with <code>ParamSpec</code>","text":"<p>Introduced in Python 3.10, <code>ParamSpec</code> allows annotating decorators and generic functions while preserving original function signatures:</p> <pre><code># example_4.py\nfrom typing import Callable, ParamSpec, TypeVar\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef logging_decorator(func: Callable[P, R]) -&gt; Callable[P, R]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        print(f\"Calling {func.__name__} with {args} and {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@logging_decorator\ndef multiply(a: int, b: int) -&gt; int:\n    return a * b\n\nmultiply(2, 3)  # Output: Calling multiply with (2, 3) and {} then returns 6\n</code></pre> <p><code>ParamSpec</code> helps decorators maintain accurate type information for wrapped functions.</p>"},{"location":"08%20Callable_Types/#implementing-function-overloading-with-overload","title":"Implementing Function Overloading with <code>@overload</code>","text":"<p>Python allows specifying multiple function signatures through the <code>@overload</code> decorator for better static type checking:</p> <pre><code># example_5.py\nfrom typing import overload, Union\n\n@overload\ndef double(value: int) -&gt; int: ...\n\n@overload\ndef double(value: str) -&gt; str: ...\n\ndef double(value: Union[int, str]) -&gt; Union[int, str]:\n    if isinstance(value, int):\n        return value * 2\n    return value + value\n\nprint(double(4))     # Output: 8\nprint(double(\"Hi\"))  # Output: HiHi\n</code></pre> <p><code>@overload</code> clearly defines each acceptable signature, providing strong typing and preventing misuse.</p>"},{"location":"08%20Callable_Types/#annotation-strategies-for-apis-and-libraries","title":"Annotation Strategies for APIs and Libraries","text":"<p>Clear annotations greatly enhance public API usability and reliability. Strategies include:</p>"},{"location":"08%20Callable_Types/#explicit-and-detailed-annotations","title":"Explicit and Detailed Annotations","text":"<ul> <li>Clearly annotate all public API interfaces and return types.</li> <li>Avoid overly broad types like <code>Any</code> unless necessary.</li> </ul>"},{"location":"08%20Callable_Types/#using-type-aliases-for-complex-signatures","title":"Using Type Aliases for Complex Signatures","text":"<pre><code># example_6.py\nfrom typing import Callable, TypeAlias\n\nRequestHandler: TypeAlias = Callable[[str, dict], dict]\n\ndef handle_request(path: str, handler: RequestHandler) -&gt; dict:\n    response = handler(path, {})\n    return response\n</code></pre>"},{"location":"08%20Callable_Types/#consistent-annotation-patterns","title":"Consistent Annotation Patterns","text":"<ul> <li>Follow consistent patterns for similar methods or functions within an API.</li> </ul>"},{"location":"08%20Callable_Types/#leveraging-protocols-and-callables","title":"Leveraging Protocols and Callables","text":"<p>Using <code>Protocol</code> for clearly defined callable behaviors:</p> <pre><code># example_7.py\nfrom typing import Protocol\n\nclass Handler(Protocol):\n    def __call__(self, request: dict) -&gt; dict: ...\n\ndef process_request(handler: Handler, request: dict) -&gt; dict:\n    return handler(request)\n</code></pre> <p>Following these strategies ensures type-safe, clear, and developer-friendly APIs and libraries.</p>"},{"location":"09%20Structural_Typing/","title":"Structural Typing","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"09%20Structural_Typing/#introduction","title":"Introduction","text":"<p>Python is a dynamically-typed language, but with the introduction of type hints it gained optional static typing features. In type systems, there are two fundamental ways to decide if one type is compatible with another: nominal typing and structural typing. Nominal typing (name-based typing) means type compatibility is determined by explicit declarations and the class hierarchy \u2013 an object\u2019s type is what its class name (or inheritance) says it is (Protocols and structural subtyping - mypy 1.15.0 documentation). For example, if class <code>Dog</code> inherits from class <code>Animal</code>, then <code>Dog</code> is-a subtype of <code>Animal</code> by definition, and a <code>Dog</code> instance can be used wherever an <code>Animal</code> is expected (Protocols and structural subtyping - mypy 1.15.0 documentation). This is how traditional object-oriented languages like Java or C++ work, and it\u2019s also the primary mode in Python\u2019s type system by default.</p> <p>On the other hand, structural typing determines type compatibility by the actual structure or capabilities of the object, not its explicit inheritance. In a structural type system, if an object has all the required methods and attributes of a type, then it qualifies as that type, regardless of its class name or parent classes (Protocols and structural subtyping - mypy 1.15.0 documentation). In other words, if it \u201cwalks like a duck and quacks like a duck, then it\u2019s treated as a duck\u201d \u2013 this is the essence of the famous duck typing principle. Duck typing is a runtime concept in Python: you invoke methods or attributes on an object, and as long as it supports those operations, things work (if a required method is missing, you get an <code>AttributeError</code> at runtime) (What's the Difference Between Nominal, Structural, and Duck Typing? - DEV Community) (Duck typing - Wikipedia). Structural typing can be seen as the static, compile-time equivalent of duck typing (Protocols and structural subtyping - mypy 1.15.0 documentation). Instead of waiting for a runtime error, a structural type system (with the help of a static type checker) can verify ahead of time that an object has the necessary attributes to be used in a given context. This approach is more flexible than nominal typing because it doesn\u2019t require pre-planned inheritance relationships. It is also more explicit and safe than unguarded duck typing because the structure is checked (by a type checker) before the code runs.</p> <p>Python historically embraced duck typing at runtime \u2013 you just call methods on objects and trust they exist. Prior to Python 3.8, static type checking in Python (via tools like MyPy, PyRight, etc.) was largely nominal: you would use abstract base classes or concrete classes to hint the types, and an object\u2019s class had to match the annotation or inherit from a matching class. This could make it awkward to type-hint code that was written in a duck-typed style. For instance, if you had a function that worked with any object that had a <code>.read()</code> method, there wasn\u2019t a straightforward way to express that in a type hint without making all such objects share a common base class or using <code>typing.Any</code>. Python 3.8 remedied this by introducing protocols in the <code>typing</code> module (Python Protocols: Leveraging Structural Subtyping \u2013 Real Python). Protocols allow you to define a structural interface that other classes can fulfill just by having the right methods/attributes, without inheritance. This brings the flexibility of duck typing into the realm of static type checking \u2013 essentially formalizing \u201cIf it quacks like a duck, it can be treated as a duck\u201d in the type system.</p> <p>In summary, nominal typing ties compatibility to declared relationships (e.g., subclassing an interface or abstract class), whereas structural typing ties compatibility to an object\u2019s actual shape (the presence of specific methods/attributes). Python\u2019s type system now supports both: use nominal typing for clarity and runtime consistency with class relationships, and use structural typing (via protocols) for flexibility and to more directly model Python\u2019s duck-typed nature (PEP 544 \u2013 Protocols: Structural subtyping (static duck typing) | peps.python.org).</p>"},{"location":"09%20Structural_Typing/#defining-and-using-protocols","title":"Defining and Using Protocols","text":"<p>To leverage structural typing in Python\u2019s type hints, you define protocols. A protocol in Python is essentially an interface or template for a set of methods and attributes. It\u2019s defined by inheriting from <code>typing.Protocol</code> (available in the standard library <code>typing</code> module as of Python 3.8, or in <code>typing_extensions</code> for earlier versions). By creating a class that subclasses <code>Protocol</code>, you declare a group of methods and properties that form a \u201cprotocol\u201d \u2013 any class that has those methods and properties (with compatible types) will be considered an implementation of that protocol by static type checkers, even if it doesn\u2019t formally inherit from the protocol.</p> <p>How to define a protocol: You simply create a class that inherits <code>Protocol</code> and define the method signatures (and any attribute types) that are required. Protocol methods typically have empty bodies (often using <code>...</code> or <code>pass</code>) because you\u2019re not providing an implementation, just a definition of the interface. For example, suppose we want a protocol for \u201cspeaking\u201d creatures or objects: it should have a method <code>speak()</code> that returns a string. We can define:</p> <pre><code># example_1.py\nfrom typing import Protocol\n\nclass Speaker(Protocol):\n    def speak(self) -&gt; str: ...\n</code></pre> <p>Here, <code>Speaker</code> is a protocol that any \u201cspeaker\u201d object should follow. Now, any class that defines a <code>speak(self) -&gt; str</code> method will be considered a <code>Speaker</code> for typing purposes. We can create two completely unrelated classes that fulfill this protocol without explicit inheritance:</p> <pre><code># example_2.py\nclass Dog:\n    def speak(self) -&gt; str:\n        return \"woof\"\n\nclass Robot:\n    def speak(self) -&gt; str:\n        return \"beep-boop\"\n\ndef announce(speaker: Speaker) -&gt; None:\n    # `speaker` can be any object that has .speak() returning str\n    print(\"Announcement:\", speaker.speak())\n\nannounce(Dog())    # OK, Dog has speak()\nannounce(Robot())  # OK, Robot has speak()\n</code></pre> <p>Even though <code>Dog</code> and <code>Robot</code> do not inherit from <code>Speaker</code> (and are not related to each other at all), the static type checker will accept them as valid arguments to <code>announce</code> because they structurally conform to the <code>Speaker</code> protocol by implementing the required method. This is the power of structural typing. In fact, the type checker treats <code>Dog</code> and <code>Robot</code> as subtypes of <code>Speaker</code> because they have the right <code>speak()</code> method signature (Protocols and structural subtyping - mypy 1.15.0 documentation). If we tried to pass an object that lacks a <code>speak()</code> method (or has an incompatible signature), the type checker would flag an error, ensuring type safety.</p> <p>It\u2019s important to note that protocols are primarily a static concept \u2013 they are enforced by type checkers, not by the Python runtime (by default). Unlike an abstract base class (ABC), a protocol doesn\u2019t actually require classes to formally subclass it, and Python won\u2019t automatically error at runtime if a required method is missing. For example, in the code above, if we call <code>announce(Dog())</code> and <code>Dog.speak</code> is missing or misnamed, we would only find out at runtime via an <code>AttributeError</code>. The protocol helps catch such issues before runtime by using tools like Mypy. The protocols defined in <code>typing</code> are optional and have no runtime effect on their own (PEP 544 \u2013 Protocols: Structural subtyping (static duck typing) | peps.python.org). This means you can use them freely for type hints without incurring runtime overhead or restrictions. (Protocols do inherit from <code>abc.ABC</code> under the hood, but by default <code>isinstance()</code> and <code>issubclass()</code> checks against a protocol will not work without an explicit opt-in, as we\u2019ll discuss shortly.)</p> <p>Using a protocol in type hints: Once you have a protocol class, you use it as a type in annotations just like you would use an ABC or a concrete class. In the above example, the function <code>announce</code> was annotated to accept a <code>Speaker</code>. That tells readers and type checkers that any argument should \u201cspeak\u201d. This is more expressive than using a base class like <code>Animal</code> or a union of types \u2013 we directly specify the capability we need. Another example: Python\u2019s standard library defines an <code>Iterable[T]</code> protocol (in <code>collections.abc</code> or <code>typing</code>) that essentially says the object has an <code>__iter__</code> method returning an iterator. If you annotate a function parameter as <code>Iterable[str]</code>, any object that can be iterated over to yield strings will be accepted \u2013 whether it\u2019s a list, a tuple, a custom container class with an <code>__iter__</code>, etc. The type checker doesn\u2019t require them to inherit from <code>Iterable</code>; having the method is enough (Protocols and structural subtyping - mypy 1.15.0 documentation). This demonstrates that many idiomatic Python \u201cprotocols\u201d (iteration, context managers, etc.) are recognized structurally. Python\u2019s typing module and static checkers come with several predefined protocols (either explicitly as in <code>typing.Protocol</code> classes or implicitly via ABCs with structural hooks) for common patterns.</p> <p>Let\u2019s look at a slightly more elaborate example of defining and using a protocol. Imagine we have objects that need to support a <code>close()</code> method (like files or network connections). We can define a protocol <code>Closable</code> and use it to write a function that closes a batch of resources:</p> <pre><code># example_3.py\nfrom typing import Protocol, Iterable\n\nclass Closable(Protocol):\n    def close(self) -&gt; None: ...\n\nclass FileResource:\n    def __init__(self, path: str):\n        self.file = open(path, 'w')\n    def close(self) -&gt; None:\n        self.file.close()\n\nclass SocketResource:\n    def close(self) -&gt; None:\n        print(\"Socket closed\")\n\ndef close_all(resources: Iterable[Closable]) -&gt; None:\n    for res in resources:\n        res.close()\n\n# Using the close_all function with different resource types\nclosables = [FileResource(\"data.txt\"), SocketResource(), open(\"other.txt\", \"w\")]\nclose_all(closables)  # OK: FileResource, SocketResource, and file objects all have close()\n</code></pre> <p>In this code, <code>Closable</code> is a protocol requiring a <code>.close()</code> method. We created a <code>FileResource</code> class and a <code>SocketResource</code> class that both implement <code>close()</code>. We also use a built-in file object from <code>open()</code>, which we know has a <code>close()</code> method. The <code>close_all</code> function is annotated to accept any iterable of <code>Closable</code> objects. Thanks to structural typing, it doesn\u2019t matter that these objects are of different types and don\u2019t share a common ancestor named <code>Closable</code> \u2013 as long as each has a callable <code>close()</code> method, the static type checker will be satisfied and, at runtime, the code will work. In fact, Mypy considers the built-in file object and our custom classes all as subtypes of <code>Closable</code> because they provide the required attribute (Protocols and structural subtyping - mypy 1.15.0 documentation).</p> <p>One thing to be aware of: protocols by default cannot be used with <code>isinstance()</code> or <code>issubclass()</code> checks at runtime. If you try <code>isinstance(some_obj, Closable)</code> in the above example, Python will raise a <code>TypeError</code> unless you take additional steps. This is because the protocol is not a real base class of those objects (they never inherited from it). However, Python\u2019s <code>typing</code> module provides a decorator <code>@runtime_checkable</code> that you can apply to a protocol to make runtime <code>isinstance</code> checks possible on it. Marking a protocol with <code>@runtime_checkable</code> means it gets a special <code>__instancecheck__</code> that will return True if the object has the required attributes (much like ABCs in <code>collections.abc</code> do with their <code>__subclasshook__</code>). For example:</p> <pre><code># example_4.py\nfrom typing import runtime_checkable\n\n@runtime_checkable\nclass Closable(Protocol):\n    def close(self) -&gt; None: ...\n\nisinstance(FileResource(\"data.txt\"), Closable)  # True, because FileResource has close()\n</code></pre> <p>Now <code>Closable</code> can be used in <code>isinstance</code> and <code>issubclass</code> as a structural check (Abstract Base Classes and Protocols: What Are They? When To Use Them?? Lets Find Out! - Justin A. Ellis). Use this feature carefully \u2013 it\u2019s useful for type introspection in frameworks or for asserting an object meets an interface at runtime, but it only checks the presence of attributes and not their types, and could give false positives if an attribute name matches but semantics differ. In most cases, protocols are used purely for static checking and documentation.</p>"},{"location":"09%20Structural_Typing/#practical-protocol-examples","title":"Practical Protocol Examples","text":"<p>Protocols shine in real-world scenarios where you want to decouple code and reduce dependencies on concrete classes. A common use case is dependency injection and testing. In Python, it\u2019s common to write functions or classes that operate on objects with a particular interface, without caring about the concrete implementation. Protocols let you formally capture that interface in the type system. This makes your code\u2019s expectations clear and allows static analysis to ensure you didn\u2019t violate those expectations. Let\u2019s discuss a few practical examples.</p> <p>1. Dependency injection and interchangeable components: Suppose you\u2019re writing a service that needs to log messages. You might want the ability to swap out the logger \u2013 sometimes logging to a file, sometimes to the console, or maybe collecting logs in memory for testing. You can define a protocol for the logger\u2019s interface and program against that. For instance:</p> <pre><code># example_5.py\nfrom typing import Protocol\n\nclass Logger(Protocol):\n    def log(self, message: str) -&gt; None: ...\n\nclass FileLogger:\n    \"\"\"Concrete logger that writes to a file.\"\"\"\n    def __init__(self, filename: str):\n        self.filename = filename\n    def log(self, message: str) -&gt; None:\n        with open(self.filename, 'a') as f:\n            f.write(message + '\\n')\n\nclass ListLogger:\n    \"\"\"Concrete logger that stores messages in a list (e.g., for testing).\"\"\"\n    def __init__(self):\n        self.messages: list[str] = []\n    def log(self, message: str) -&gt; None:\n        self.messages.append(message)\n\ndef run_process(task_name: str, logger: Logger) -&gt; None:\n    logger.log(f\"Starting {task_name}\")\n    # ...\nperform the task ...\n    logger.log(f\"Finished {task_name}\")\n\n# Using the run_process with different loggers\nrun_process(\"DataCleanup\", FileLogger(\"app.log\"))       # logs to file\ntest_logger = ListLogger()\nrun_process(\"DataCleanup\", test_logger)                 # logs to list in memory\nprint(\"Captured logs:\", test_logger.messages)\n</code></pre> <p>In <code>Logger(Protocol)</code>, we specify that a logger must have a <code>.log(str)</code> method. Our <code>run_process</code> function doesn\u2019t care how the logging is done, just that the object passed in can <code>.log</code> a message. <code>FileLogger</code> and <code>ListLogger</code> are two implementations \u2013 one writes to a file, the other stores messages in a Python list. Notice that neither <code>FileLogger</code> nor <code>ListLogger</code> subclasses <code>Logger</code>; they don\u2019t need to. They implicitly satisfy the protocol by having the correct <code>log</code> method. This design is very flexible: you can add new logger classes later (say, a <code>DatabaseLogger</code> that writes to a database, or reuse Python\u2019s built-in <code>logging.Logger</code> by writing an adapter that has a <code>log</code> method) without changing the code that uses the logger. During testing, as shown, we can use <code>ListLogger</code> to capture logs and make assertions on them. The static type checker will ensure that any object we pass as a <code>logger</code> to <code>run_process</code> has a <code>log(str)</code> method. In a nominal type system, you might have to define an abstract base class <code>Logger</code> and make every logger inherit it. With protocols, you get the benefit of an interface without the inheritance \u2013 this reduces coupling and makes it easier to integrate third-party classes that weren\u2019t written with your ABC in mind (Python Protocols: Leveraging Structural Subtyping \u2013 Real Python) (Abstract Base Classes and Protocols: What Are They? When To Use Them?? Lets Find Out! - Justin A. Ellis).</p> <p>2. Testing with fake or mock objects: Building on the above example, protocols are extremely handy for unit testing. In tests, we often use fake objects or mocks to simulate real components (like databases, web services, etc.) without having to perform the real operations. With protocols, you can give those test doubles a clear interface. For example, if you have a function that fetches data from an API, you could define a protocol for the fetcher. In production you pass a real HTTP client, in tests you pass a dummy object that returns predetermined data. The protocol assures the dummy has the same method signature as the real client. This avoids type checker warnings and makes tests cleaner. (It\u2019s essentially the static typing analog of using an interface in other languages for dependency injection in tests.) Many testing libraries (like <code>unittest.mock</code>) create dynamic mocks that can be configured with attributes on the fly; to type-annotate those, you can either cast them to a Protocol or use a Protocol as a base for a dummy implementation. Using protocols in this way documents exactly what methods a mock is expected to provide. This can prevent situations where your test double is missing a method or has a typo that wouldn\u2019t be caught until runtime. In short, whenever you say \u201cI need an object that can do X in my code, and I might swap different implementations of it,\u201d that\u2019s a cue to define a protocol for X.</p> <p>3. Interface design and third-party integration: Protocols can serve as interfaces in your application design. Even if you\u2019re not writing multiple implementations immediately, defining a protocol for a role in your system can clarify the design. For example, you might define a <code>DataStore</code> protocol with methods like <code>save(item)</code> and <code>load(id)</code> that any storage backend should implement. Today you only have a database implementation, but tomorrow you might add an in-memory or file-based implementation \u2013 the protocol makes the contract clear. Moreover, if you want to accept objects from a third-party library that already have the necessary methods, protocols let you do so without subclassing or modifying those classes (Abstract Base Classes and Protocols: What Are They? When To Use Them?? Lets Find Out! - Justin A. Ellis). Suppose you\u2019re writing a function that can output data to any \u201cfile-like\u201d object (something with a <code>.write()</code> method). The <code>io.TextIOBase</code> abstract class in Python is nominal, but not every file-like object will inherit it. By defining your own protocol with a <code>write(str)</code> method, your function can accept a wide range of objects (actual file handles, <code>io.StringIO</code> instances, custom writer objects) as long as they implement <code>write</code>. This is especially useful when working with libraries that weren\u2019t built with your interfaces; you can adapt them via protocols instead of being forced into their class hierarchy. Protocols thus increase reusability and extensibility of your code by focusing on what an object can do rather than what it is.</p> <p>It\u2019s worth mentioning that Python\u2019s standard library and frameworks have embraced the concept of protocols (even before the formal <code>Protocol</code> type existed) by using \u201cduck typing\u201d and abstract base classes. For instance, the act of iterating in Python checks for an <code>__iter__</code> method \u2013 any object that has <code>__iter__</code> is iterable. The static typing system knows this too: you don\u2019t have to explicitly register your class as an <code>Iterable</code> ABC; if it has the right method, tools like Mypy will treat it as iterable (Protocols and structural subtyping - mypy 1.15.0 documentation). With <code>Protocol</code>, we can create our own such abstractions. In modern Python, the combination of protocols and <code>@runtime_checkable</code> even lets us approximate some features of a language with a built-in interface system.</p> <p>4. Composition and adapters using protocols: Another practical pattern is using protocols to enable composition and decorators. Because protocols don\u2019t require inheritance, you can make wrapper classes that add functionality while still conforming to an interface. For example, you might have a basic service class and then a logging wrapper class that takes a service and also implements the same service protocol to proxy calls and add logging. As long as both implement the protocol, code using the protocol can accept either the plain or the wrapped version. This was illustrated by defining an <code>AddServiceProtocol</code> for an addition service and creating both a normal implementation and a logging decorator implementation that forwards calls (Protocols and Composition in Python - DEV Community). The key takeaway is that structural typing focuses on the behavior, so even objects that don\u2019t share a lineage can work together if they fulfill the same behavioral contract.</p>"},{"location":"09%20Structural_Typing/#combining-protocols-with-generics","title":"Combining Protocols with Generics","text":"<p>Protocols become even more powerful when combined with generics. Just like classes and functions can be generic (using <code>TypeVar</code> to operate over a range of types), protocol classes can be generic as well. A generic protocol allows you to define a protocol that is parameterized by a type (or multiple types), enabling more precise typing of method arguments and return values. Many built-in protocols are generic \u2013 for example, <code>Iterable[T]</code> is a protocol that can be <code>Iterable[int]</code>, <code>Iterable[str]</code>, etc., depending on what type it yields. We can do the same with our own protocols.</p> <p>To define a generic protocol, we use <code>TypeVar</code> and put the type variable in brackets after <code>Protocol</code> when defining the class (Python Protocols: Leveraging Structural Subtyping \u2013 Real Python). Let\u2019s say we want to define a simple container protocol that yields items of some type. We can make it generic so that a <code>Container[int]</code> will be a protocol for \u201ccontainer of ints\u201d and <code>Container[str]</code> for \u201ccontainer of strings,\u201d but both are based on the same generic interface. For example:</p> <pre><code># example_6.py\nfrom typing import Protocol, TypeVar\n\nT = TypeVar('T')\n\nclass Container(Protocol[T]):\n    def get_item(self) -&gt; T: ...\n</code></pre> <p>Here, <code>Container[T]</code> is a generic protocol with a single type variable <code>T</code>. It specifies one method <code>get_item</code> that returns an object of type <code>T</code>. Now we can implement this protocol for different types by providing concrete type parameters. For instance, a container of strings and a container of integers:</p> <pre><code># example_7.py\nclass StringContainer:\n    def __init__(self, value: str):\n        self.value = value\n    def get_item(self) -&gt; str:\n        return self.value\n\nclass IntContainer:\n    def __init__(self, value: int):\n        self.value = value\n    def get_item(self) -&gt; int:\n        return self.value\n</code></pre> <p><code>StringContainer</code> and <code>IntContainer</code> each implement <code>get_item</code> returning the appropriate type. They don\u2019t subclass <code>Container</code>, but structurally they match <code>Container[str]</code> and <code>Container[int]</code> respectively. We can write functions that use the generic protocol to accept any kind of container and preserve the type information of the contained item:</p> <pre><code># example_8.py\ndef print_item_and_return[C](container: Container[C]) -&gt; C:\n    item = container.get_item()\n    print(\"Got:\", item)\n    return item  # The type of item is inferred as C\n\n# Using the generic function with different container types:\nx = print_item_and_return(StringContainer(\"hello\"))  # prints \"hello\", x is str\ny = print_item_and_return(IntContainer(42))          # prints \"42\", y is int\n</code></pre> <p>In the function <code>print_item_and_return</code>, we used <code>C</code> (could also use <code>T</code> again) as a type variable for the container\u2019s item type. When we call this function with a <code>StringContainer</code>, the type checker knows <code>C</code> is <code>str</code> in that call, so it infers that the function returns a <code>str</code>. Similarly, with <code>IntContainer</code>, <code>C</code> becomes <code>int</code>. This is the benefit of generic protocols: they let you write flexible code that is still type-safe and retains specific type information. In other words, one protocol can work for many types without losing the ability to distinguish those types when it matters. The syntax we used (<code>Container[C]</code> inside the function annotation) leverages Python\u2019s ability to support generics in type hints. (Under the hood, <code>Container[int]</code> is a parameterized protocol instance, but conceptually you can think of it like an interface template.)</p> <p>Keep in mind that user-defined generic protocols follow the same rules as normal generic classes for type checking (PEP 544 \u2013 Protocols: Structural subtyping (static duck typing) | peps.python.org). You can declare variance for type variables if needed (covariant, contravariant) using <code>typing.Final</code> or by special syntax in <code>TypeVar</code>, although if you don\u2019t declare, the type checker will assume invariance (meaning <code>Container[SubClass]</code> is not a subtype of <code>Container[BaseClass]</code> unless you marked variance). In our container example, this is not an issue because we\u2019re primarily using it to carry the exact type.</p> <p>Another scenario for combining protocols with generics is when you want to put protocols as bounds on <code>TypeVar</code>s. For instance, you can declare <code>T = TypeVar('T', bound=SomeProtocol)</code> to indicate that a type variable must satisfy a certain protocol. This is analogous to saying \u201cT must be a subtype of this Protocol,\u201d except since protocols aren\u2019t part of the class hierarchy, it really means any type used for T must structurally implement the protocol. For example, if we have:</p> <pre><code># example_9.py\nT = TypeVar('T', bound=Logger)  # using our Logger protocol from earlier\n</code></pre> <p>This means any type filling in for T must have a <code>.log(str) -&gt; None</code> method. You could use such a bound in a generic function or class to ensure the operations you perform on T (like calling <code>log</code>) are valid. This is a powerful way to write generic algorithms that operate on any objects meeting a certain interface, without tying them to a base class.</p> <p>It\u2019s also worth noting that Python 3.12 introduced an even more concise way to define generic protocols (and generic classes in general) by allowing type variables in the definition of methods directly (PEP 695 \u2013 Type Parameter Syntax). For instance, one could write something like:</p> <pre><code># example_10.py\nclass Container(Protocol):\n    def get_item[T](self) -&gt; T: ...\n</code></pre> <p>to define a generic method <code>get_item</code> in a protocol. However, under the hood this still creates a generic protocol with a type variable <code>T</code>. Most code at the time of writing still uses the earlier syntax with explicit <code>TypeVar</code> declarations, which is what we\u2019ve shown above.</p> <p>In summary, combining protocols with generics lets you express very flexible and reusable type relationships. You can create protocols that work over a family of types while still preserving type information. Many of Python\u2019s built-in protocols are generic (for example, an iterator protocol <code>Iterator[T]</code> yields items of type T), and you can do the same in your own designs (Python Protocols: Leveraging Structural Subtyping \u2013 Real Python) (Python Protocols: Leveraging Structural Subtyping \u2013 Real Python). This enables things like container types, numeric operations, or callback interfaces to be both generic and structural. When designing a generic protocol, think about what parts of the interface should change with the type (those become type variables) and which are fixed. The result is a very powerful abstraction that remains easy to use.</p>"},{"location":"09%20Structural_Typing/#when-to-choose-structural-typing-over-nominal-typing","title":"When to Choose Structural Typing Over Nominal Typing","text":"<p>Now that we\u2019ve explored what structural typing (via protocols) and nominal typing (via concrete classes or ABCs) offer, a natural question arises: When should you use one over the other? The answer often depends on the context and goals. Both approaches have their strengths, and in Python they complement each other rather than one completely replacing the other (PEP 544 \u2013 Protocols: Structural subtyping (static duck typing) | peps.python.org). Here are some guidelines, pros and cons, and best practices to help decide:</p> <p>Use nominal typing (classes/ABCs) when:</p> <ul> <li>You want to reuse code via inheritance. If you have default method implementations or shared attributes that can be defined in a base class, an abstract base class can provide that. Inheritance isn\u2019t the only way to reuse code, but when it makes sense (e.g. a base class providing common functionality), nominal typing naturally goes along with it because subclasses inherit from the base.  </li> <li>You need a strict class hierarchy or runtime type information. If it\u2019s important in your design to maintain actual subclass relationships (perhaps for identity checks, <code>isinstance</code> checks, or because you rely on Python\u2019s method resolution order and <code>super()</code> calls), then using nominal types is appropriate. For example, if you have a plugin system where all plugins must register as subclasses of <code>BasePlugin</code> to be discovered, that\u2019s a nominal approach.  </li> <li>The interface is large or complex, with many methods, and tightly coupled to an implementation. While you could model this with a protocol, it may be clearer to use an abstract class to group behavior. If multiple methods are meant to be overridden together, an ABC can enforce that at instantiation time (trying to instantiate a subclass that hasn\u2019t implemented all abstract methods raises an error). In short, for class designs that naturally form an \u201cis-a\u201d hierarchy and possibly share some code, nominal typing fits well.</li> </ul> <p>Use structural typing (protocols) when:</p> <ul> <li>You want to keep it lightweight and focused purely on the method/attribute requirements. Protocols are great for defining a narrow interface that multiple disparate classes can implement without formal coupling. If you only care about one or a few methods on an object (and not about its exact type), a protocol lets you specify just that. This is especially useful for function parameters: you can annotate a function to accept any object that has a <code>.close()</code> method, or a <code>.write()</code> method, etc., without forcing a common base class (Abstract Base Classes and Protocols: What Are They? When To Use Them?? Lets Find Out! - Justin A. Ellis).  </li> <li>You are working with third-party or existing classes that you can\u2019t modify to fit into your class hierarchy. Structural typing shines here because you can define a protocol that matches the external class\u2019s capabilities. For example, if a 3rd-party library gives you objects that have a <code>.to_json()</code> method, and you want to treat those objects uniformly in your code, you can create a <code>ToJsonable</code> protocol with <code>to_json(self) -&gt; str</code> and use that in your type hints. Any object from the library will satisfy the protocol if it has the method, without you needing to make it inherit from anything (Abstract Base Classes and Protocols: What Are They? When To Use Them?? Lets Find Out! - Justin A. Ellis). This decoupling is very powerful in a language as dynamic as Python, where often we \u201cduck type\u201d through frameworks \u2013 now you can put an actual type hint on it.  </li> <li>You need generic interfaces or extension of existing ones. Protocols are useful for creating ad-hoc interfaces that might not have been foreseen initially. For instance, you might realize that two classes in different parts of your system happen to have similar methods for, say, resetting their state. You could retroactively define a <code>Resettable</code> protocol and update type hints to use it, without touching the classes themselves. If later you make those classes formally implement an ABC, fine \u2013 but the protocol gave you an immediate way to express the concept in types and check it. Additionally, if you\u2019re designing a library and want to allow users to plug in their own objects (as long as they have certain methods), providing a protocol in your public API documentation is a nice way to communicate that. Users can either implement that Protocol (statically) or just ensure their classes match the signature.</li> </ul> <p>Pros and Cons Summary: Nominal typing (using concrete classes and ABCs) offers clarity in terms of design \u2013 it\u2019s very clear that ClassX is a kind of InterfaceY because it explicitly inherits it. It also allows enforcement: abstract base classes can ensure at runtime that certain methods are implemented (attempting to instantiate a subclass that hasn\u2019t implemented an abstract method will error out). They can also provide default behavior. However, nominal typing is less flexible \u2013 everything must be planned or adapted to fit the hierarchy. If you want an external class to be treated as an InterfaceY, you might have to write an adapter or subclass it, which could be clunky or impossible (if you don\u2019t control that class). Structural typing (using protocols) is extremely flexible and mirrors Python\u2019s dynamic nature \u2013 you get to \u201cwrite the interface after the fact.\u201d It encourages designing for capabilities rather than inheritance. The downside is that protocols are primarily static \u2013 they rely on the developer running a type checker. Python won\u2019t stop you from passing an object that doesn\u2019t fulfill the protocol (until you call a missing method and get an error at runtime, just like normal duck typing). So if you need guaranteed enforcement in a running program, protocols alone won\u2019t give you that (they are optional). That said, in a team or project using type checks as part of CI, protocols can prevent a lot of mistakes. Another minor con is that protocols, if overused, could make it less obvious which classes actually implement which interface; with nominal typing you can always search for subclasses of an ABC. In practice, a mix is often best: use protocols for the broad \u201cthis is what we expect\u201d contracts especially for external boundaries and flexible APIs, and use concrete classes or ABCs internally when you want more structure or reuse.</p> <p>Best practices: It\u2019s not an either/or choice \u2013 you can use both in the same codebase. For example, you might define an ABC with some default methods for a complex interface, but also define a protocol for a subset of that interface for use in a more generic function. Choose structural typing when you want minimal coupling and maximum flexibility, especially at boundaries of your system or for \u201cpluggable\u201d functionality. Choose nominal typing when you want an explicit, enforced contract and possibly to leverage inheritance of code. Remember that protocols are most valuable when you are using static type checking; if your project doesn\u2019t use type checks, then a protocol is simply a <code>abc.ABC</code> with no abstract methods \u2013 it won\u2019t enforce anything by itself at runtime. In such cases, if enforcement is needed, an ABC with abstract methods (or even just documentation) might be better. However, even in purely dynamic contexts, many developers find protocols useful as documentation: by reading the Protocol class, you know what an object is expected to do.</p> <p>In Python\u2019s type system evolution, protocols were introduced to complement nominal typing, not to replace it (PEP 544 \u2013 Protocols: Structural subtyping (static duck typing) | peps.python.org). They give you the freedom to write code in the Pythonic duck-typed style while still reaping the benefits of static analysis. A good guideline is to use protocols to describe roles that can be played by objects of different class hierarchies, and use nominal typing for relationships within a class hierarchy. By following these practices, you can make your code both flexible and robust, leveraging the best of both worlds in Python\u2019s type system.</p>"},{"location":"10%20Make_Illegal_Types_Unrepresentable/","title":"Make Illegal Types Unrepresentable","text":""},{"location":"11%20Errors_As_Values/","title":"Errors As Values","text":""},{"location":"12%20Advanced_Typing_Concepts/","title":"Advanced Typing Concepts","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"12%20Advanced_Typing_Concepts/#literal-types-definition-and-practical-usage","title":"Literal Types: Definition and Practical Usage","text":"<p>Literal types allow specifying exact permissible values, enhancing type specificity and correctness:</p> <pre><code># example_1.py\nfrom typing import Literal\n\ndef set_mode(mode: Literal['auto', 'manual']) -&gt; None:\n    print(f\"Mode set to {mode}\")\n\nset_mode('auto')  # valid\n# set_mode('automatic')  # invalid, detected by type checker\n</code></pre> <p>Literal types ensure values match expected exact constants, improving type safety.</p>"},{"location":"12%20Advanced_Typing_Concepts/#annotated-types-annotated-for-metadata","title":"Annotated Types (<code>Annotated[...]</code>) for Metadata","text":"<p><code>Annotated</code> provides metadata for types, useful in documentation, validation, or frameworks:</p> <pre><code># example_2.py\nfrom typing import Annotated\n\nUserID = Annotated[int, \"Database primary key\"]\n\ndef fetch_user(user_id: UserID) -&gt; dict:\n    return {\"id\": user_id, \"name\": \"Alice\"}\n</code></pre> <p>Metadata within <code>Annotated</code> helps convey additional context beyond simple type hints.</p>"},{"location":"12%20Advanced_Typing_Concepts/#defining-and-using-newtype","title":"Defining and Using <code>NewType</code>","text":"<p><code>NewType</code> creates distinct types for stronger type checking without runtime overhead:</p> <pre><code># example_3.py\nfrom typing import NewType\n\nUserId = NewType('UserId', int)\n\nuser_id = UserId(42)\n\ndef get_user(uid: UserId) -&gt; str:\n    return f\"User {uid}\"\n\n# get_user(42)  # type checker error\nget_user(user_id)  # correct usage\n</code></pre> <p><code>NewType</code> improves clarity, preventing accidental misuse of similar underlying types.</p>"},{"location":"12%20Advanced_Typing_Concepts/#advanced-type-narrowing-techniques","title":"Advanced Type Narrowing Techniques","text":"<p>Type narrowing refines a variable's type within conditional checks:</p>"},{"location":"12%20Advanced_Typing_Concepts/#using-isinstance","title":"Using <code>isinstance</code>","text":"<pre><code># example_4.py\nfrom typing import Union\n\ndef process(value: Union[int, str]) -&gt; None:\n    if isinstance(value, int):\n        print(value + 1)\n    else:\n        print(value.upper())\n</code></pre>"},{"location":"12%20Advanced_Typing_Concepts/#using-assertions","title":"Using assertions","text":"<pre><code># example_5.py\nfrom typing import Optional\n\ndef greet(name: Optional[str]) -&gt; None:\n    assert name is not None, \"Name cannot be None\"\n    print(f\"Hello, {name}\")\n</code></pre> <p>Type narrowing helps write precise, safe, and understandable code.</p>"},{"location":"12%20Advanced_Typing_Concepts/#type-guards-isinstance-custom-type-guards-assertions","title":"Type Guards (<code>isinstance</code>, custom type guards, assertions)","text":"<p>Custom type guards offer explicit ways to narrow types more clearly:</p>"},{"location":"12%20Advanced_Typing_Concepts/#custom-type-guard-functions-python-310","title":"Custom type guard functions (Python 3.10+)","text":"<pre><code># example_6.py\nfrom typing import TypeGuard\n\nclass Cat:\n    def meow(self):\n        print(\"Meow!\")\n\ndef is_cat(animal: object) -&gt; TypeGuard[Cat]:\n    return hasattr(animal, 'meow')\n\nanimal = Cat()\nif is_cat(animal):\n    animal.meow()  # Safe to call\n</code></pre> <p>Type guards enhance type narrowing accuracy, making code safer and cleaner.</p>"},{"location":"12%20Advanced_Typing_Concepts/#variance-covariance-and-contravariance-in-generics","title":"Variance, Covariance, and Contravariance in Generics","text":"<p>Variance controls type relationships between generic types:</p>"},{"location":"12%20Advanced_Typing_Concepts/#covariance-covarianttrue","title":"Covariance (<code>covariant=True</code>)","text":"<p>Allows using subtypes in place of parent types:</p> <pre><code># example_7.py\nfrom typing import Generic, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)\n\nclass ReadOnlyList(Generic[T_co]):\n    def __init__(self, items: list[T_co]):\n        self.items = items\n\nints: ReadOnlyList[int] = ReadOnlyList([1, 2, 3])\nnumbers: ReadOnlyList[float] = ints  # Valid due to covariance\n</code></pre>"},{"location":"12%20Advanced_Typing_Concepts/#contravariance-contravarianttrue","title":"Contravariance (<code>contravariant=True</code>)","text":"<p>Allows using parent types in place of subtypes, common in callbacks or consumers:</p> <pre><code># example_8.py\nT_contra = TypeVar('T_contra', contravariant=True)\n\nclass Processor(Generic[T_contra]):\n    def process(self, value: T_contra) -&gt; None:\n        print(value)\n\nint_processor: Processor[int] = Processor()\nnumber_processor: Processor[float] = int_processor  # Valid due to contravariance\n</code></pre> <p>Understanding variance ensures accurate type relationships, especially when designing flexible APIs or libraries.</p>"},{"location":"13%20Pattern_Matching_And_Typing/","title":"Pattern Matching And Typing","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"13%20Pattern_Matching_And_Typing/#introduction-to-structural-pattern-matching-python-310","title":"Introduction to Structural Pattern Matching (Python 3.10+)","text":"<p>Python 3.10 introduced structural pattern matching, providing powerful and concise syntax to match objects against specific patterns:</p> <pre><code># example_1.py\ndef handle_command(command: str) -&gt; str:\n    match command:\n        case \"start\":\n            return \"Starting\"\n        case \"stop\":\n            return \"Stopping\"\n        case _:\n            return \"Unknown command\"\n</code></pre> <p>Pattern matching enhances readability and maintainability, reducing the complexity of conditional logic.</p>"},{"location":"13%20Pattern_Matching_And_Typing/#annotating-code-with-pattern-matching","title":"Annotating Code with Pattern Matching","text":"<p>Annotations can clarify patterns used in structural matching, making code clearer and aiding static type checking:</p> <pre><code># example_2.py\nfrom typing import Union\n\nclass Success:\n    def __init__(self, result: str):\n        self.result = result\n\nclass Error:\n    def __init__(self, error: str):\n        self.error = error\n\ndef process(response: Union[Success, Error]) -&gt; str:\n    match response := response:\n        case Success(result=result):\n            return f\"Success: {result}\"\n        case Error(error):\n            return f\"Error: {error}\"\n</code></pre> <p>This use of annotations and pattern matching simplifies complex decision-making logic.</p>"},{"location":"13%20Pattern_Matching_And_Typing/#annotating-code-with-pattern-matching_1","title":"Annotating Code with Pattern Matching","text":"<p>When combining type annotations with pattern matching, carefully structuring types enhances type checker effectiveness:</p>"},{"location":"13%20Pattern_Matching_And_Typing/#example-with-typeddict-and-pattern-matching","title":"Example with TypedDict and Pattern Matching","text":"<pre><code># example_3.py\nfrom typing import TypedDict\n\nclass Command(TypedDict):\n    action: str\n    payload: dict\n\ndef process_command(command: TypedDict) -&gt; None:\n    match command:\n        case {\"action\": \"create\", \"item\": item}:\n            print(f\"Creating {item}\")\n        case {\"action\": \"delete\", \"id\": int() as item_id}:\n            print(f\"Deleting item {item_id}\")\n        case _:\n            print(\"Unknown command\")\n</code></pre> <p>Annotations clearly define expected data shapes, improving readability and correctness.</p>"},{"location":"13%20Pattern_Matching_And_Typing/#type-checking-considerations-with-match-statements","title":"Type Checking Considerations with <code>match</code> Statements","text":"<p>Static type checkers can analyze pattern matching effectively, but careful type design is essential:</p>"},{"location":"13%20Pattern_Matching_And_Typing/#ensuring-consistent-patterns","title":"Ensuring Consistent Patterns","text":"<p>Pattern matching works best with clearly annotated and structurally consistent types:</p> <pre><code># example_4.py\nfrom typing import Union\n\nclass Cat:\n    def meow(self) -&gt; str:\n        return \"Meow\"\n\nclass Dog:\n    def bark(self) -&gt; str:\n        return \"Woof\"\n\ndef animal_sound(animal: Union[Cat, Dog]) -&gt; str:\n    match animal:\n        case Cat():\n            return animal.meow()\n        case Dog():\n            return animal.bark()\n</code></pre> <p>Properly annotated unions simplify handling of multiple types with clarity and safety.</p>"},{"location":"13%20Pattern_Matching_And_Typing/#real-world-scenarios-for-pattern-matching","title":"Real-world Scenarios for Pattern Matching","text":"<p>Pattern matching is highly effective in real-world scenarios, such as:</p>"},{"location":"13%20Pattern_Matching_And_Typing/#handling-api-responses","title":"Handling API Responses","text":"<pre><code># example_5.py\ndef process_response(response: dict) -&gt; str:\n    match response:\n        case {\"status\": \"success\", \"data\": data}:\n            return f\"Success: {data}\"\n        case {\"status\": \"error\", \"message\": error_msg}:\n            return f\"Error: {error}\"\n        case _:\n            return \"Unknown response format\"\n</code></pre>"},{"location":"13%20Pattern_Matching_And_Typing/#parsing-complex-data-structures","title":"Parsing Complex Data Structures","text":"<pre><code># example_6.py\ndef parse_coordinates(coords: tuple) -&gt; str:\n    match coords := coords:\n        case (float(lat), float(lon)):\n            return f\"Latitude: {lat}, Longitude: {lon}\"\n        case _:\n            return \"Invalid coordinates\"\n</code></pre> <p>Pattern matching simplifies conditional logic, making code more maintainable.</p>"},{"location":"13%20Pattern_Matching_And_Typing/#type-checking-considerations","title":"Type Checking Considerations","text":"<p>Ensure type annotations match patterns closely, as type checkers use them to validate correctness:</p> <ul> <li>Explicitly define type annotations for better static analysis.</li> <li>Carefully match patterns to annotated types for enhanced safety.</li> </ul> <p>Properly using pattern matching alongside type annotations helps catch potential runtime errors early, resulting in safer and more readable Python code.</p>"},{"location":"14%20Async/","title":"Async","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"14%20Async/#type-annotations-for-async-functions","title":"Type Annotations for Async Functions","text":"<p>Async functions (<code>async def</code>) support type annotations similarly to regular functions, clearly specifying their input and return types:</p> <pre><code># example_1.py\nimport asyncio\n\nasync def fetch_data(url: str) -&gt; str:\n    await asyncio.sleep(1)\n    return f\"Data from {url}\"\n</code></pre> <p>Clear type annotations improve readability and debugging, especially in asynchronous codebases.</p>"},{"location":"14%20Async/#annotating-coroutine-awaitable-and-async-generators","title":"Annotating <code>Coroutine</code>, <code>Awaitable</code>, and Async Generators","text":"<p>Python provides specific annotations for asynchronous constructs, enhancing type safety and correctness:</p>"},{"location":"14%20Async/#coroutine","title":"<code>Coroutine</code>","text":"<p>Explicitly type coroutines:</p> <pre><code># example_2.py\nfrom typing import Coroutine\n\nasync def get_user(user_id: int) -&gt; dict:\n    return {\"id\": user_id, \"name\": \"Alice\"}\n\nasync def main() -&gt; Coroutine[None, None, dict]:\n    user = await get_user(123)\n    return user\n</code></pre>"},{"location":"14%20Async/#awaitable","title":"<code>Awaitable</code>","text":"<p>For functions returning awaitable results:</p> <pre><code># example_3.py\nfrom typing import Awaitable\n\nasync def fetch(url: str) -&gt; str:\n    return f\"Content from {url}\"\n\ndef schedule_fetch(url: str) -&gt; Awaitable[str]:\n    return fetch(url)\n</code></pre>"},{"location":"14%20Async/#async-generators","title":"Async Generators","text":"<p>For asynchronous generators:</p> <pre><code># example_4.py\nfrom typing import AsyncGenerator\n\nasync def stream_data() -&gt; AsyncGenerator[int, None]:\n    for i in range(5):\n        yield i\n</code></pre> <p>These specialized annotations clarify asynchronous behaviors and interactions.</p>"},{"location":"14%20Async/#type-safe-async-context-managers","title":"Type-safe Async Context Managers","text":"<p>Async context managers manage resources in asynchronous contexts, with annotations improving safety and clarity:</p> <pre><code># example_5.py\nfrom contextlib import asynccontextmanager\nfrom typing import AsyncGenerator\n\n@asynccontextmanager\nasync def database_connection() -&gt; AsyncGenerator[str, None]:\n    connection = \"db_connection\"\n    try:\n        yield connection\n    finally:\n        await asyncio.sleep(1)  # simulate closing connection\n\nasync def main():\n    async with database_connection() as conn:\n        print(f\"Using {conn}\")\n</code></pre> <p>Annotations provide explicit clarity, improving resource management and reducing errors.</p>"},{"location":"14%20Async/#best-practices-for-typed-async-python-applications","title":"Best Practices for Typed Async Python Applications","text":""},{"location":"14%20Async/#clearly-annotate-async-functions","title":"Clearly Annotate Async Functions","text":"<ul> <li>Explicitly state return types to enhance readability.</li> <li>Use specialized async annotations (<code>Awaitable</code>, <code>Coroutine</code>) for clarity.</li> </ul>"},{"location":"14%20Async/#consistent-use-of-async-types","title":"Consistent Use of Async Types","text":"<ul> <li>Avoid mixing synchronous and asynchronous types inconsistently.</li> <li>Clearly differentiate async generators and synchronous generators.</li> </ul>"},{"location":"14%20Async/#use-async-context-managers-effectively","title":"Use Async Context Managers Effectively","text":"<ul> <li>Annotate context managers clearly to indicate resource management explicitly.</li> <li>Ensure proper setup and teardown in async contexts.</li> </ul>"},{"location":"14%20Async/#integrate-async-type-checking-in-cicd","title":"Integrate Async Type Checking in CI/CD","text":"<ul> <li>Include <code>mypy</code> or <code>pyright</code> checks in CI pipelines specifically for async code.</li> <li>Regularly verify correct async annotations to maintain consistency.</li> </ul> <p>Applying these best practices ensures robust, readable, and maintainable asynchronous Python code.</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/","title":"Interoperability And Typing Stubs","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#introduction-to-pyi-stub-files","title":"Introduction to <code>.pyi</code> Stub Files","text":"<p><code>.pyi</code> stub files provide type annotations for Python modules, especially useful when source code lacks annotations or is unavailable:</p> <ul> <li>Contains type definitions without actual implementations.</li> <li>Enables static type checking for third-party libraries.</li> </ul> <p>Example:</p> <pre><code># example_1.py\n# math.pyi\ndef sqrt(x: float) -&gt; float: ...\n</code></pre> <p>Stub files clearly document expected types, significantly improving interoperability.</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#generating-stubs-automatically-with-stubgen","title":"Generating Stubs Automatically with <code>stubgen</code>","text":"<p><code>stubgen</code> is a tool included with <code>mypy</code> to automatically generate stub files from existing Python code:</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#installation-and-basic-use","title":"Installation and Basic Use","text":"<pre><code>pip install mypy\nstubgen -m your_module\n</code></pre> <p>Generates a <code>.pyi</code> file with inferred annotations, saving manual effort:</p> <pre><code># example_2.py\n# Generated example.pyi\ndef greet(name: str) -&gt; str: ...\n</code></pre> <p>Auto-generated stubs provide a starting point for type annotations.</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#writing-effective-stubs-manually","title":"Writing Effective Stubs Manually","text":"<p>Manual stub writing is essential when automatic inference is insufficient:</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#example-stub-file","title":"Example Stub File","text":"<pre><code># example_3.py\n# custom_module.pyi\nclass User:\n    id: int\n    name: str\n\ndef fetch_user(user_id: int) -&gt; User: ...\n</code></pre>"},{"location":"15%20Interoperability_And_Typing_Stubs/#best-practices","title":"Best Practices","text":"<ul> <li>Clearly annotate arguments and return types.</li> <li>Use ellipsis (<code>...</code>) to indicate stub implementation.</li> <li>Reflect original module's behavior accurately.</li> </ul> <p>Manual stub files enhance readability and ensure accurate type definitions.</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#distributing-and-versioning-typing-stubs","title":"Distributing and Versioning Typing Stubs","text":"<p>Typing stubs can be distributed independently or alongside the original package:</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#bundled-with-package","title":"Bundled with Package","text":"<p>Include stubs directly in your package:</p> <pre><code>your_package/\n\u251c\u2500\u2500 __init__.py\n\u2514\u2500\u2500 __init__.pyi\n</code></pre>"},{"location":"15%20Interoperability_And_Typing_Stubs/#separate-distribution","title":"Separate Distribution","text":"<p>Publish stubs as standalone packages:</p> <pre><code>pip install types-requests\n</code></pre> <p>Use semantic versioning aligned with the original package for clarity and compatibility:</p> <pre><code>types-requests==2.25.1\n</code></pre> <p>Effective versioning ensures seamless integration and updates.</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#typing-third-party-libraries-without-native-annotations","title":"Typing Third-party Libraries without Native Annotations","text":"<p>When third-party libraries lack native annotations:</p>"},{"location":"15%20Interoperability_And_Typing_Stubs/#use-third-party-typing-packages","title":"Use Third-party Typing Packages","text":"<p>Install existing typing packages from PyPI:</p> <pre><code>pip install types-requests\n</code></pre>"},{"location":"15%20Interoperability_And_Typing_Stubs/#custom-stubs","title":"Custom Stubs","text":"<p>Write custom stub files within your project:</p> <pre><code>stubs/\n\u251c\u2500\u2500 requests.pyi\n</code></pre>"},{"location":"15%20Interoperability_And_Typing_Stubs/#ignoring-missing-annotations","title":"Ignoring Missing Annotations","text":"<p>Temporarily ignore missing annotations with <code>mypy</code> configuration:</p> <pre><code>[mypy-requests]\nignore_missing_imports = True\n</code></pre> <p>Using stubs significantly improves type checking for libraries without built-in annotations, maintaining robust and reliable codebases.</p>"},{"location":"16%20Best_Practices/","title":"Best Practices","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"16%20Best_Practices/#effective-patterns-for-clear-and-maintainable-annotations","title":"Effective Patterns for Clear and Maintainable Annotations","text":"<p>Clear type annotations significantly improve code quality and maintainability:</p>"},{"location":"16%20Best_Practices/#consistent-type-annotation-style","title":"Consistent Type Annotation Style","text":"<ul> <li>Standardize type annotations across your project.</li> <li>Clearly annotate function signatures, class attributes, and return types.</li> </ul> <pre><code># example_1.py\ndef calculate_area(width: float, height: float) -&gt; float:\n    return width * height\n</code></pre>"},{"location":"16%20Best_Practices/#use-type-aliases-for-complex-types","title":"Use Type Aliases for Complex Types","text":"<p>Simplify repetitive or complex annotations:</p> <pre><code># example_2.py\nfrom typing import Dict, List\n\nUserData = Dict[str, List[int]]\n\ndef process_data(data: UserData) -&gt; None:\n    pass\n</code></pre> <p>Type aliases enhance readability, making complex types easier to understand.</p>"},{"location":"16%20Best_Practices/#leverage-dataclasses-and-typeddicts","title":"Leverage Dataclasses and TypedDicts","text":"<ul> <li>Dataclasses simplify structured data definitions.</li> <li>TypedDicts clarify expected dictionary structures.</li> </ul> <pre><code># example_3.py\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    id: int\n    name: str\n</code></pre> <p>These patterns improve explicitness and reduce boilerplate code.</p>"},{"location":"16%20Best_Practices/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":""},{"location":"16%20Best_Practices/#overusing-any","title":"Overusing <code>Any</code>","text":"<p>Overuse of <code>Any</code> defeats the purpose of type annotations:</p> <ul> <li>Pitfall:</li> </ul> <pre><code># example_4.py\n\ndef process(data: Any) -&gt; Any:\n    pass\n</code></pre> <ul> <li>Solution:   Provide specific type annotations whenever possible.</li> </ul>"},{"location":"16%20Best_Practices/#missing-or-inconsistent-annotations","title":"Missing or Inconsistent Annotations","text":"<p>Incomplete annotations lead to confusion:</p> <ul> <li>Always annotate public APIs clearly.</li> <li>Regularly review annotations during code reviews.</li> </ul>"},{"location":"16%20Best_Practices/#complex-union-types","title":"Complex Union Types","text":"<p>Avoid overly complex union types:</p> <ul> <li>Pitfall:</li> </ul> <p>```python</p>"},{"location":"16%20Best_Practices/#example_5py","title":"example_5.py","text":""},{"location":"16%20Best_Practices/#example_5py_1","title":"example_5.py","text":"<p>def handle(value: Union[int, str, None, float]) -&gt; None:       pass</p> <p>```</p> <ul> <li>Solution:   Refactor to simplify or use custom types.</li> </ul>"},{"location":"16%20Best_Practices/#balancing-simplicity-readability-and-explicitness","title":"Balancing Simplicity, Readability, and Explicitness","text":""},{"location":"16%20Best_Practices/#simplicity","title":"Simplicity","text":"<ul> <li>Aim for the simplest annotation that accurately represents the type.</li> </ul>"},{"location":"16%20Best_Practices/#readability","title":"Readability","text":"<ul> <li>Ensure annotations improve, rather than obscure, readability.</li> </ul>"},{"location":"16%20Best_Practices/#explicitness","title":"Explicitness","text":"<ul> <li>Favor explicit annotations that clarify intent, especially at API boundaries.</li> </ul> <p>Striking the right balance ensures maintainable and understandable code.</p>"},{"location":"16%20Best_Practices/#strategies-for-large-scale-typed-codebases","title":"Strategies for Large-Scale Typed Codebases","text":"<p>Managing large-scale typed codebases requires strategic approaches:</p>"},{"location":"16%20Best_Practices/#incremental-adoption","title":"Incremental Adoption","text":"<ul> <li>Gradually introduce type annotations to existing codebases.</li> <li>Prioritize critical and frequently changed components.</li> </ul>"},{"location":"16%20Best_Practices/#automate-type-checking","title":"Automate Type Checking","text":"<ul> <li>Integrate tools like <code>mypy</code> and <code>pyright</code> into CI/CD.</li> <li>Regularly enforce type checking to maintain standards.</li> </ul>"},{"location":"16%20Best_Practices/#continuous-review-and-improvement","title":"Continuous Review and Improvement","text":"<ul> <li>Regularly review annotations during code reviews.</li> <li>Address inconsistencies and improve clarity over time.</li> </ul>"},{"location":"16%20Best_Practices/#comprehensive-documentation","title":"Comprehensive Documentation","text":"<ul> <li>Document type annotation standards and best practices.</li> <li>Ensure all team members follow consistent annotation strategies.</li> </ul> <p>Implementing these strategies helps sustain clarity, maintainability, and robustness in large, typed Python projects.</p>"},{"location":"A1%20Quick_Reference/","title":"Quick Reference","text":"Annotation Description Example <code>int</code>, <code>str</code>, <code>float</code>, <code>bool</code> Basic built-in types <code>age: int = 25</code> <code>List[T]</code>, <code>list[T]</code> List containing items of type <code>T</code> <code>scores: list[int]</code> <code>Tuple[T, ...]</code> Tuple with specified item types <code>coords: tuple[float, float]</code> <code>Dict[K, V]</code>, <code>dict[K, V]</code> Dictionary with keys <code>K</code>, values <code>V</code> <code>user_data: dict[str, int]</code> <code>Set[T]</code>, <code>set[T]</code> Set containing items of type <code>T</code> <code>tags: set[str]</code> <code>Optional[T]</code> Type <code>T</code> or <code>None</code> <code>name: Optional[str]</code> <code>Union[T1, T2]</code> or <code>T1 | T2</code> Either type <code>T1</code> or <code>T2</code> <code>value: int | str</code> <code>Callable[[Args], ReturnType]</code> Function types <code>adder: Callable[[int, int], int]</code> <code>Literal[\"value\"]</code> Specific literal values <code>mode: Literal[\"auto\", \"manual\"]</code> <code>Annotated[T, metadata]</code> Type <code>T</code> with additional metadata <code>UserID = Annotated[int, \"primary key\"]</code> <code>NewType('Name', T)</code> New distinct type based on type <code>T</code> <code>UserId = NewType('UserId', int)</code> <code>Protocol</code> Structural typing protocol <code>class Speaker(Protocol): ...</code>"},{"location":"A2%20Glossary/","title":"Glossary","text":"Term Definition Annotation Explicit type declaration for variables, functions, or classes. Duck Typing Determining an object's suitability based on presence of methods/attributes Generics Type annotations parameterized by type variables. Literal Types Types representing specific literal values. Protocol Interface defined by structural compatibility, rather than explicit inheritance. Stub Files Files (<code>.pyi</code>) containing type annotations without implementations. Type Alias Simplified or descriptive alias for complex type annotations. Type Checking Verification of type consistency either statically or at runtime. Type Narrowing Refining variable types within specific control-flow branches. Variance Rules describing subtype relationships between generic types (covariant, contravariant). Static Typing Types checked before execution (compile-time). Dynamic Typing Types determined and checked during execution (runtime). Covariance Generic type that accepts subtypes as substitutes for its type parameter. Contravariance Generic type that accepts supertypes as substitutes for its type parameter. Invariant Generic type that requires exact type matches for its type parameters."},{"location":"A3%20Type_Checkers/","title":"Type Checkers","text":"<p>This placeholder text was generated by ChatGPT 4.5. It will be significantly rewritten as the book is developed. In the meantime you can add comments to either https://bsky.app/bruceeckel or Github Issues.</p>"},{"location":"A3%20Type_Checkers/#getting-started-with-mypy-installation-and-basic-use","title":"Getting Started with <code>mypy</code>: Installation and Basic Use","text":"<p><code>mypy</code> is a popular static type checker for Python that validates type annotations:</p>"},{"location":"A3%20Type_Checkers/#installation","title":"Installation","text":"<pre><code>pip install mypy\n</code></pre>"},{"location":"A3%20Type_Checkers/#basic-use","title":"Basic Use","text":"<p>Run <code>mypy</code> on your script or module to identify type errors:</p> <pre><code>mypy your_script.py\n</code></pre> <p>Example:</p> <pre><code># example_1.py\n# script.py\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ngreet(123)  # Incorrect type\n</code></pre> <p>Running <code>mypy script.py</code> outputs:</p> <pre><code>script.py:4: error: Argument 1 to \"greet\" has incompatible type \"int\"; expected \"str\"\n</code></pre>"},{"location":"A3%20Type_Checkers/#advanced-configuration-and-fine-tuning-of-mypy","title":"Advanced Configuration and Fine-tuning of <code>mypy</code>","text":"<p>Customize <code>mypy</code> behavior using a <code>mypy.ini</code> or <code>pyproject.toml</code> file:</p>"},{"location":"A3%20Type_Checkers/#example-mypyini","title":"Example <code>mypy.ini</code>","text":"<pre><code>[mypy]\nignore_missing_imports = True\nstrict = True\ncheck_untyped_defs = True\n</code></pre>"},{"location":"A3%20Type_Checkers/#example-pyprojecttoml","title":"Example <code>pyproject.toml</code>","text":"<pre><code>[tool.mypy]\nignore_missing_imports = true\nstrict = true\n</code></pre> <p>Advanced configuration allows precise control over type-checking behavior and strictness levels.</p>"},{"location":"A3%20Type_Checkers/#exploring-pyright-and-ide-integration-vscode-pycharm","title":"Exploring <code>pyright</code> and IDE Integration (VSCode, PyCharm)","text":"<p><code>pyright</code>, developed by Microsoft, offers high-performance static type checking, integrated seamlessly with popular IDEs.</p>"},{"location":"A3%20Type_Checkers/#using-pyright-cli","title":"Using <code>pyright</code> (CLI)","text":"<p>Install globally using npm:</p> <pre><code>npm install -g pyright\npyright your_script.py\n</code></pre>"},{"location":"A3%20Type_Checkers/#vscode-integration","title":"VSCode Integration","text":"<p><code>pyright</code> powers VSCode's built-in Python type checking, providing immediate feedback:</p> <ul> <li>Install the Python extension in VSCode.</li> <li>Real-time inline error highlighting and suggestions.</li> </ul>"},{"location":"A3%20Type_Checkers/#pycharm-integration","title":"PyCharm Integration","text":"<p>PyCharm supports built-in type checking:</p> <ul> <li>Provides live error detection, highlighting, and quick-fix suggestions.</li> <li>Navigate to <code>Preferences &gt; Editor &gt; Inspections</code> to configure type-checking rules.</li> </ul>"},{"location":"A3%20Type_Checkers/#incremental-typing-strategies-gradual-adoption","title":"Incremental Typing Strategies: Gradual Adoption","text":"<p>Adopt typing gradually, focusing first on critical paths:</p> <ul> <li>Annotate high-risk or frequently changing modules first.</li> <li>Enable type checking incrementally to avoid overwhelming your team:</li> </ul> <pre><code>[mypy]\nfiles = core/, utils/\n</code></pre> <p>Incremental typing balances immediate benefits with manageable adoption efforts.</p>"},{"location":"A3%20Type_Checkers/#integrating-type-checking-into-continuous-integration","title":"Integrating Type Checking into Continuous Integration","text":"<p>Automate type checking within your CI/CD pipeline to enforce consistency and catch errors early:</p>"},{"location":"A3%20Type_Checkers/#example-github-actions-workflow","title":"Example GitHub Actions Workflow","text":"<pre><code>name: Type Check\n\non: [push, pull_request]\n\njobs:\n  type-check:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v3\n        with:\n          python-version: '3.11'\n\n      - run: pip install mypy\n      - run: mypy .\n</code></pre> <p>Automated checks ensure ongoing compliance with typing standards and maintain high code quality.</p>"},{"location":"A3%20Type_Checkers/#handling-and-resolving-common-errors","title":"Handling and Resolving Common Errors","text":"<p>Common type-checking errors and their resolutions:</p>"},{"location":"A3%20Type_Checkers/#incorrect-type-annotation","title":"Incorrect Type Annotation","text":"<pre><code># example_2.py\n# Error: Incompatible types in assignment (expression has type \"int\", variable has type \"str\")\nname: str = 123  # fix: name = \"Alice\"\n</code></pre>"},{"location":"A3%20Type_Checkers/#missing-imports","title":"Missing Imports","text":"<p>Use <code>ignore_missing_imports</code> or install type stubs:</p> <pre><code>[mypy]\nignore_missing_imports = True\n</code></pre> <p>Or install stubs:</p> <pre><code>pip install types-requests\n</code></pre>"},{"location":"A3%20Type_Checkers/#union-and-optional-errors","title":"Union and Optional Errors","text":"<p>Resolve ambiguity clearly:</p> <pre><code># example_3.py\nfrom typing import Optional\n\n# Error: Incompatible return value type (got \"None\", expected \"int\")\ndef find_index(item: str, items: list[str]) -&gt; Optional[int]:\n    try:\n        return items.index(item)\n    except ValueError:\n        return None\n</code></pre> <p>Effectively handling and resolving these errors leads to clearer, more reliable, and maintainable codebases.</p>"}]}